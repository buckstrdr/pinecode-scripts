//@version=6
// DISCLAIMER: This strategy is provided "as is" for educational and backtesting purposes only. BucksTRDR is not responsible for trading decisions made using this tool. Always do your own research and consult a financial professional.
strategy('Volume Breakout Trailing Strategy by BucksTRDR', overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, commission_type=strategy.commission.cash_per_contract, commission_value=2)

// === Strategy Inputs ===
volumeMALength = input.int(20, title='Volume MA Length', minval=1, group='Volume Settings', tooltip='Length for volume moving average')
volumeMultiplier = input.float(1.5, title='Volume Multiplier', minval=0.1, step=0.1, group='Volume Settings', tooltip='Minimum volume multiplier vs MA (e.g. 1.5 = 150%)')

minCandleRange = input.float(5.0, title='Min Trigger Candle Range (points)', minval=0.1, step=0.1, group='Candle Filters', tooltip='Minimum size of trigger candle in points')
maxCandleRange = input.float(50.0, title='Max Trigger Candle Range (points)', minval=0.1, step=1.0, group='Candle Filters', tooltip='Maximum size of trigger candle in points')
minTrailCandleSize = input.float(3.0, title='Min Candle Size for Trailing (points)', minval=0.1, step=0.1, group='Candle Filters', tooltip='Minimum candle size to move stop loss')

tickOffset = input.float(2.0, title='Tick Offset for First SL Move', minval=0, step=0.5, group='Stop Loss Settings', tooltip='Offset in ticks for first stop loss move (to cover fees)')

// Debug option
showDebugLabels = input.bool(false, title='Show Debug Labels', group='Display', tooltip='Show debug information on chart')

// === Timeframe Check ===
is5min = timeframe.isintraday and timeframe.multiplier == 5

// === Volume Calculations ===
volumeMA = ta.sma(volume, volumeMALength)
volumeCondition = volume >= volumeMultiplier * volumeMA

// === Candle Calculations ===
candleRange = high - low
candleIsBullish = close > open
candleIsBearish = close < open

// === Trigger Candle Conditions ===
validCandleRange = candleRange >= minCandleRange and candleRange <= maxCandleRange
triggerLong = is5min and candleIsBullish and volumeCondition and validCandleRange
triggerShort = is5min and candleIsBearish and volumeCondition and validCandleRange

// === Track Position State ===
var float entryPrice = na
var float currentStopLoss = na
var int tradeDirection = 0  // 1 = long, -1 = short, 0 = no position
var bool firstTrailMove = false  // Track if we've made the first SL adjustment
var float lastCandleClose = na  // Track previous candle close for trailing

// === Entry Logic ===
if triggerLong and strategy.position_size == 0
    entryPrice := close
    currentStopLoss := low
    tradeDirection := 1
    firstTrailMove := true
    lastCandleClose := close
    strategy.entry('Long', strategy.long)

    if showDebugLabels
        label.new(bar_index, high, 'ðŸŸ¢ LONG ENTRY\nVol: ' + str.tostring(volume/volumeMA, '#.##') + 'x\nRange: ' + str.tostring(candleRange, '#.##'),
                  style=label.style_label_down, color=color.green, textcolor=color.white, size=size.small)

if triggerShort and strategy.position_size == 0
    entryPrice := close
    currentStopLoss := high
    tradeDirection := -1
    firstTrailMove := true
    lastCandleClose := close
    strategy.entry('Short', strategy.short)

    if showDebugLabels
        label.new(bar_index, low, 'ðŸ”´ SHORT ENTRY\nVol: ' + str.tostring(volume/volumeMA, '#.##') + 'x\nRange: ' + str.tostring(candleRange, '#.##'),
                  style=label.style_label_up, color=color.red, textcolor=color.white, size=size.small)

// === Trailing Stop Logic ===
if strategy.position_size > 0  // Long position
    // Check if candle continues in our direction and meets minimum size
    candleContinues = close > lastCandleClose
    candleMeetsMinSize = candleRange >= minTrailCandleSize

    if candleContinues and candleMeetsMinSize
        // Calculate new stop loss
        if firstTrailMove
            // First move: add tick offset for fees
            currentStopLoss := lastCandleClose + (tickOffset * syminfo.mintick)
            firstTrailMove := false

            if showDebugLabels
                label.new(bar_index, low, 'ðŸ“ˆ 1st Trail\nSL: ' + str.tostring(currentStopLoss, format.mintick) + '\n(+' + str.tostring(tickOffset) + ' ticks)',
                          style=label.style_label_up, color=color.blue, textcolor=color.white, size=size.tiny)
        else
            // Subsequent moves: just use previous candle close
            currentStopLoss := lastCandleClose

            if showDebugLabels
                label.new(bar_index, low, 'ðŸ“ˆ Trail\nSL: ' + str.tostring(currentStopLoss, format.mintick),
                          style=label.style_label_up, color=color.aqua, textcolor=color.black, size=size.tiny)

    // Update last candle close for next bar
    lastCandleClose := close

    // Apply stop loss
    strategy.exit('Long Exit', 'Long', stop=currentStopLoss)

if strategy.position_size < 0  // Short position
    // Check if candle continues in our direction and meets minimum size
    candleContinues = close < lastCandleClose
    candleMeetsMinSize = candleRange >= minTrailCandleSize

    if candleContinues and candleMeetsMinSize
        // Calculate new stop loss
        if firstTrailMove
            // First move: subtract tick offset for fees
            currentStopLoss := lastCandleClose - (tickOffset * syminfo.mintick)
            firstTrailMove := false

            if showDebugLabels
                label.new(bar_index, high, 'ðŸ“‰ 1st Trail\nSL: ' + str.tostring(currentStopLoss, format.mintick) + '\n(-' + str.tostring(tickOffset) + ' ticks)',
                          style=label.style_label_down, color=color.blue, textcolor=color.white, size=size.tiny)
        else
            // Subsequent moves: just use previous candle close
            currentStopLoss := lastCandleClose

            if showDebugLabels
                label.new(bar_index, high, 'ðŸ“‰ Trail\nSL: ' + str.tostring(currentStopLoss, format.mintick),
                          style=label.style_label_down, color=color.orange, textcolor=color.black, size=size.tiny)

    // Update last candle close for next bar
    lastCandleClose := close

    // Apply stop loss
    strategy.exit('Short Exit', 'Short', stop=currentStopLoss)

// === Reset on Position Close ===
if strategy.position_size == 0 and strategy.position_size[1] != 0
    entryPrice := na
    currentStopLoss := na
    tradeDirection := 0
    firstTrailMove := false
    lastCandleClose := na

// === Visual Reference ===
// Plot entry signals
plotshape(triggerLong, title='Long Trigger', style=shape.triangleup, location=location.belowbar, color=color.new(color.green, 0), size=size.small)
plotshape(triggerShort, title='Short Trigger', style=shape.triangledown, location=location.abovebar, color=color.new(color.red, 0), size=size.small)

// Plot stop loss line
plot(strategy.position_size != 0 ? currentStopLoss : na, title='Stop Loss', color=color.red, linewidth=2, style=plot.style_linebr)

// === Volume Reference ===
bgcolor(volumeCondition ? color.new(color.blue, 95) : na, title='High Volume Background')
