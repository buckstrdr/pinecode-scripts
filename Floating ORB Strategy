//@version=6
// DISCLAIMER: This strategy is provided "as is" for educational and backtesting purposes only. BucksTRDR is not responsible for trading decisions made using this tool. Always do your own research and consult a financial professional.
strategy('Floating ORB Strategy by BucksTRDR', overlay=true,
         fill_orders_on_standard_ohlc=true,
         initial_capital=1000000,
         default_qty_type=strategy.percent_of_equity,
         default_qty_value=100,
         commission_type=strategy.commission.cash_per_contract,
         commission_value=2)

// === Strategy Inputs ===
volumeMALength = input.int(20, title='Volume MA Length', minval=1, group='Volume Settings', tooltip='Length for volume moving average')
volumeMultiplier = input.float(1.5, title='Volume Multiplier', minval=0.1, step=0.1, group='Volume Settings', tooltip='Minimum volume multiplier vs MA (e.g. 1.5 = 150%)')

minCandleRange = input.float(5.0, title='Min Trigger Candle Range (points)', minval=0.1, step=0.1, group='Candle Filters', tooltip='Minimum size of trigger candle in points')
maxCandleRange = input.float(50.0, title='Max Trigger Candle Range (points)', minval=0.1, step=1.0, group='Candle Filters', tooltip='Maximum size of trigger candle in points')
minTrailCandleSize = input.float(3.0, title='Min Candle Size for Trailing (points)', minval=0.1, step=0.1, group='Candle Filters', tooltip='Minimum candle size to move stop loss')

tickOffset = input.float(2.0, title='Tick Offset for First SL Move', minval=0, step=0.5, group='Stop Loss Settings', tooltip='Offset in ticks for first stop loss move (to cover fees)')

// === Time Filter Inputs ===
enableTimeFilter = input.bool(false, title='Enable Time Filter', group='Time Filter', tooltip='Only trade during specific hours')
tradingSession = input.session('0930-1600', title='Trading Hours', group='Time Filter', tooltip='Time window for entries (in exchange timezone)')
closeOutsideHours = input.bool(false, title='Close Positions Outside Hours', group='Time Filter', tooltip='Close any open positions when outside trading hours')

// === End of Day Close ===
enableEODClose = input.bool(true, title='Enable End of Day Close', group='Time Filter', tooltip='Close all positions at specific time')
eodCloseTime = input.string('2100', title='EOD Close Time (UTC)', group='Time Filter', tooltip='Time to close all positions (24hr format, e.g. 2100 for 9pm UTC)')

// Debug option
showDebugLabels = input.bool(true, title='Show Debug Labels', group='Display', tooltip='Show debug information on chart')
showFailedConditions = input.bool(true, title='Show Failed Condition Labels', group='Display', tooltip='Show why trades did not trigger')

// === Timeframe Check ===
is5min = timeframe.isintraday and timeframe.multiplier == 5

// === Time Filter Check ===
inTradingWindow = not enableTimeFilter or not na(time(timeframe.period, tradingSession))

// === End of Day Close Check ===
// Parse EOD time (e.g., "2100" = 21:00 = 9pm)
eodHour = str.tonumber(str.substring(eodCloseTime, 0, 2))
eodMinute = str.tonumber(str.substring(eodCloseTime, 2, 4))
currentHour = hour(time, 'UTC')
currentMinute = minute(time, 'UTC')

// Check if we've reached EOD close time
isEODCloseTime = enableEODClose and currentHour == eodHour and currentMinute == eodMinute

// === Volume Calculations ===
volumeMA = ta.sma(volume, volumeMALength)
volumeCondition = volume >= volumeMultiplier * volumeMA

// === Candle Calculations ===
candleRange = high - low
candleIsBullish = close > open
candleIsBearish = close < open

// === Trigger Candle Conditions ===
validCandleRange = candleRange >= minCandleRange and candleRange <= maxCandleRange
triggerLong = is5min and candleIsBullish and volumeCondition and validCandleRange and inTradingWindow
triggerShort = is5min and candleIsBearish and volumeCondition and validCandleRange and inTradingWindow

// === Debug Failed Conditions ===
if showFailedConditions and strategy.position_size == 0
    // Check if we have a potential signal but missing one condition
    potentialLong = candleIsBullish and (volumeCondition or validCandleRange or is5min or inTradingWindow)
    potentialShort = candleIsBearish and (volumeCondition or validCandleRange or is5min or inTradingWindow)

    if potentialLong and not triggerLong
        debugText = 'âš ï¸ LONG SIGNAL FAILED:\n'
        debugText := debugText + 'Timeframe: ' + (is5min ? 'âœ“' : 'âœ— NOT 5min') + '\n'
        debugText := debugText + 'Bullish: ' + (candleIsBullish ? 'âœ“' : 'âœ—') + '\n'
        debugText := debugText + 'Volume: ' + (volumeCondition ? 'âœ“' : 'âœ— ' + str.tostring(volume/volumeMA, '#.##') + 'x MA') + '\n'
        debugText := debugText + 'Range: ' + (validCandleRange ? 'âœ“' : 'âœ— ' + str.tostring(candleRange, '#.##') + ' pts') + '\n'
        debugText := debugText + 'Min: ' + str.tostring(minCandleRange, '#.#') + ' Max: ' + str.tostring(maxCandleRange, '#.#') + '\n'
        debugText := debugText + 'Time: ' + (inTradingWindow ? 'âœ“' : 'âœ— Outside hours')
        label.new(bar_index, high, debugText, style=label.style_label_down, color=color.new(color.orange, 0), textcolor=color.black, size=size.tiny)

    if potentialShort and not triggerShort
        debugText = 'âš ï¸ SHORT SIGNAL FAILED:\n'
        debugText := debugText + 'Timeframe: ' + (is5min ? 'âœ“' : 'âœ— NOT 5min') + '\n'
        debugText := debugText + 'Bearish: ' + (candleIsBearish ? 'âœ“' : 'âœ—') + '\n'
        debugText := debugText + 'Volume: ' + (volumeCondition ? 'âœ“' : 'âœ— ' + str.tostring(volume/volumeMA, '#.##') + 'x MA') + '\n'
        debugText := debugText + 'Range: ' + (validCandleRange ? 'âœ“ ' : 'âœ— ' + str.tostring(candleRange, '#.##') + ' pts') + '\n'
        debugText := debugText + 'Min: ' + str.tostring(minCandleRange, '#.#') + ' Max: ' + str.tostring(maxCandleRange, '#.#') + '\n'
        debugText := debugText + 'Time: ' + (inTradingWindow ? 'âœ“' : 'âœ— Outside hours')
        label.new(bar_index, low, debugText, style=label.style_label_up, color=color.new(color.orange, 0), textcolor=color.black, size=size.tiny)

// === Track Position State ===
var float entryPrice = na
var float currentStopLoss = na
var int tradeDirection = 0  // 1 = long, -1 = short, 0 = no position
var bool firstTrailMove = false  // Track if we've made the first SL adjustment
var float lastCandleClose = na  // Track previous candle close for trailing

// === Entry Logic ===
if triggerLong and strategy.position_size == 0
    entryPrice := close
    currentStopLoss := low
    tradeDirection := 1
    firstTrailMove := true
    lastCandleClose := close
    strategy.entry('Long', strategy.long)

    if showDebugLabels
        label.new(bar_index, high, 'ðŸŸ¢ LONG ENTRY\nVol: ' + str.tostring(volume/volumeMA, '#.##') + 'x\nRange: ' + str.tostring(candleRange, '#.##'),
                  style=label.style_label_down, color=color.green, textcolor=color.white, size=size.small)

if triggerShort and strategy.position_size == 0
    entryPrice := close
    currentStopLoss := high
    tradeDirection := -1
    firstTrailMove := true
    lastCandleClose := close
    strategy.entry('Short', strategy.short)

    if showDebugLabels
        label.new(bar_index, low, 'ðŸ”´ SHORT ENTRY\nVol: ' + str.tostring(volume/volumeMA, '#.##') + 'x\nRange: ' + str.tostring(candleRange, '#.##'),
                  style=label.style_label_up, color=color.red, textcolor=color.white, size=size.small)

// === Trailing Stop Logic ===
if strategy.position_size > 0  // Long position
    // Check if candle continues in our direction and meets minimum size
    candleContinues = close > lastCandleClose
    candleMeetsMinSize = candleRange >= minTrailCandleSize

    if candleContinues and candleMeetsMinSize
        // Calculate new stop loss
        if firstTrailMove
            // First move: add tick offset for fees
            currentStopLoss := lastCandleClose + (tickOffset * syminfo.mintick)
            firstTrailMove := false

            if showDebugLabels
                label.new(bar_index, low, 'ðŸ“ˆ 1st Trail\nSL: ' + str.tostring(currentStopLoss, format.mintick) + '\n(+' + str.tostring(tickOffset) + ' ticks)',
                          style=label.style_label_up, color=color.blue, textcolor=color.white, size=size.tiny)
        else
            // Subsequent moves: just use previous candle close
            currentStopLoss := lastCandleClose

            if showDebugLabels
                label.new(bar_index, low, 'ðŸ“ˆ Trail\nSL: ' + str.tostring(currentStopLoss, format.mintick),
                          style=label.style_label_up, color=color.aqua, textcolor=color.black, size=size.tiny)

    // Update last candle close for next bar
    lastCandleClose := close

    // Apply stop loss
    strategy.exit('Long Exit', 'Long', stop=currentStopLoss)

if strategy.position_size < 0  // Short position
    // Check if candle continues in our direction and meets minimum size
    candleContinues = close < lastCandleClose
    candleMeetsMinSize = candleRange >= minTrailCandleSize

    if candleContinues and candleMeetsMinSize
        // Calculate new stop loss
        if firstTrailMove
            // First move: subtract tick offset for fees
            currentStopLoss := lastCandleClose - (tickOffset * syminfo.mintick)
            firstTrailMove := false

            if showDebugLabels
                label.new(bar_index, high, 'ðŸ“‰ 1st Trail\nSL: ' + str.tostring(currentStopLoss, format.mintick) + '\n(-' + str.tostring(tickOffset) + ' ticks)',
                          style=label.style_label_down, color=color.blue, textcolor=color.white, size=size.tiny)
        else
            // Subsequent moves: just use previous candle close
            currentStopLoss := lastCandleClose

            if showDebugLabels
                label.new(bar_index, high, 'ðŸ“‰ Trail\nSL: ' + str.tostring(currentStopLoss, format.mintick),
                          style=label.style_label_down, color=color.orange, textcolor=color.black, size=size.tiny)

    // Update last candle close for next bar
    lastCandleClose := close

    // Apply stop loss
    strategy.exit('Short Exit', 'Short', stop=currentStopLoss)

// === Close Positions Outside Trading Hours ===
if closeOutsideHours and not inTradingWindow
    if strategy.position_size > 0
        strategy.close('Long', comment='Outside Trading Hours')
    if strategy.position_size < 0
        strategy.close('Short', comment='Outside Trading Hours')

// === End of Day Close ===
if isEODCloseTime
    if strategy.position_size > 0
        strategy.close('Long', comment='EOD Close 21:00 UTC')
        if showDebugLabels
            label.new(bar_index, high, 'ðŸ”” EOD CLOSE\n21:00 UTC', style=label.style_label_down, color=color.new(color.purple, 0), textcolor=color.white, size=size.small)
    if strategy.position_size < 0
        strategy.close('Short', comment='EOD Close 21:00 UTC')
        if showDebugLabels
            label.new(bar_index, low, 'ðŸ”” EOD CLOSE\n21:00 UTC', style=label.style_label_up, color=color.new(color.purple, 0), textcolor=color.white, size=size.small)

// === Reset on Position Close ===
if strategy.position_size == 0 and strategy.position_size[1] != 0
    entryPrice := na
    currentStopLoss := na
    tradeDirection := 0
    firstTrailMove := false
    lastCandleClose := na

// === Visual Reference ===
// Plot entry signals
plotshape(triggerLong, title='Long Trigger', style=shape.triangleup, location=location.belowbar, color=color.new(color.green, 0), size=size.small)
plotshape(triggerShort, title='Short Trigger', style=shape.triangledown, location=location.abovebar, color=color.new(color.red, 0), size=size.small)

// Plot stop loss line
plot(strategy.position_size != 0 ? currentStopLoss : na, title='Stop Loss', color=color.red, linewidth=2, style=plot.style_linebr)

// === Volume Reference ===
bgcolor(volumeCondition ? color.new(color.blue, 95) : na, title='High Volume Background')
