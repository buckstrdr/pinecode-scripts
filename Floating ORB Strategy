//@version=6
// DISCLAIMER: This strategy is provided "as is" for educational and backtesting purposes only. BucksTRDR is not responsible for trading decisions made using this tool. Always do your own research and consult a financial professional.
strategy('Floating ORB Strategy by BucksTRDR', overlay=true,
         fill_orders_on_standard_ohlc=true,
         initial_capital=1000000,
         default_qty_type=strategy.fixed,
         default_qty_value=2,
         commission_type=strategy.commission.cash_per_contract,
         commission_value=2,
         pyramiding=0)

// === Strategy Inputs ===
volumeMALength = input.int(20, title='Volume MA Length', minval=1, group='Volume Settings', tooltip='Length for volume moving average')
volumeMultiplier = input.float(1.5, title='Volume Multiplier', minval=0.1, step=0.1, group='Volume Settings', tooltip='Minimum volume multiplier vs MA (e.g. 1.5 = 150%)')

minCandleRange = input.float(10.0, title='Min Trigger Candle Range (points)', minval=0.1, step=0.1, group='Candle Filters', tooltip='Minimum size of trigger candle in points')
maxCandleRange = input.float(50.0, title='Max Trigger Candle Range (points)', minval=0.1, step=1.0, group='Candle Filters', tooltip='Maximum size of trigger candle in points')
minTrailCandleSize = input.float(3.0, title='Min Candle Size for Trailing (points)', minval=0.1, step=0.1, group='Candle Filters', tooltip='Minimum candle size to move stop loss')

tickOffset = input.float(2.0, title='Tick Offset for First SL Move', minval=0, step=0.5, group='Stop Loss Settings', tooltip='Offset in ticks for first stop loss move (to cover fees)')

// === Take Profit & Scaling Settings ===
enableFixedTP = input.bool(true, title='Enable Fixed Take Profit', group='Take Profit', tooltip='Use fixed 4:1 reward-risk take profit')
tpRatio = input.float(4.0, title='Take Profit Ratio', minval=1.0, step=0.5, group='Take Profit', tooltip='Reward-risk ratio for take profit (e.g., 4.0 = 4:1)')
scaleOutPercent = input.float(25.0, title='Scale Out % at TP', minval=10, maxval=90, step=5, group='Take Profit', tooltip='Percentage of position to close at take profit')

// === Consecutive Loss Protection ===
enableLossFilter = input.bool(false, title='Enable Loss Filter', group='Risk Management', tooltip='Stop trading after consecutive losses (DISABLED by default due to deadlock issue)')
maxConsecutiveLosses = input.int(3, title='Max Consecutive Losses', minval=1, maxval=10, group='Risk Management', tooltip='Stop trading after this many losses in a row')
lossFilterCooldownBars = input.int(20, title='Cooldown Bars After Max Losses', minval=1, maxval=200, group='Risk Management', tooltip='Number of bars to wait before resetting after max losses hit')

// === ATR Volatility Filter ===
enableATRFilter = input.bool(false, title='Enable ATR Filter', group='Volatility Filter', tooltip='Only trade when market has sufficient volatility')
atrLength = input.int(14, title='ATR Length', minval=1, group='Volatility Filter', tooltip='Length for ATR calculation')
minATR = input.float(8.0, title='Min ATR for Entry', minval=1.0, step=1.0, group='Volatility Filter', tooltip='Minimum ATR value required to enter trades')

// === Trend Filter Inputs ===
enableTrendFilter = input.bool(false, title='Enable Trend Filter', group='Trend Filter', tooltip='Only trade in direction of trend')
trendEMALength = input.int(200, title='Trend EMA Length', minval=1, group='Trend Filter', tooltip='EMA length for trend direction (e.g., 200)')

// === Time Filter Inputs ===
enableTimeFilter = input.bool(false, title='Enable Time Filter', group='Time Filter', tooltip='Only trade during specific hours')
tradingSession = input.session('0930-1600', title='Trading Hours', group='Time Filter', tooltip='Time window for entries (in exchange timezone)')
closeOutsideHours = input.bool(false, title='Close Positions Outside Hours', group='Time Filter', tooltip='Close any open positions when outside trading hours')

// === End of Day Close ===
enableEODClose = input.bool(true, title='Enable End of Day Close', group='Time Filter', tooltip='Close all positions at specific time')
eodCloseTime = input.string('2100', title='EOD Close Time (UTC)', group='Time Filter', tooltip='Time to close all positions (24hr format, e.g. 2100 for 9pm UTC)')

// === Avoid Choppy Hours ===
enableChoppyFilter = input.bool(true, title='Avoid Choppy Hours', group='Time Filter', tooltip='Avoid trading during low-liquidity choppy periods')
choppyStartHour = input.int(13, title='Choppy Start Hour (UTC)', minval=0, maxval=23, group='Time Filter', tooltip='Start of choppy period to avoid')
choppyEndHour = input.int(17, title='Choppy End Hour (UTC)', minval=0, maxval=23, group='Time Filter', tooltip='End of choppy period to avoid')

// Debug option
showDebugLabels = input.bool(true, title='Show Debug Labels', group='Display', tooltip='Show debug information on chart')
showFailedConditions = input.bool(true, title='Show Failed Condition Labels', group='Display', tooltip='Show why trades did not trigger')

// === Timeframe Check ===
is5min = timeframe.isintraday and timeframe.multiplier == 5

// === Time Filter Check ===
inTradingWindow = not enableTimeFilter or not na(time(timeframe.period, tradingSession))

// === End of Day Close Check ===
// Parse EOD time (e.g., "2100" = 21:00 = 9pm)
eodHour = str.tonumber(str.substring(eodCloseTime, 0, 2))
eodMinute = str.tonumber(str.substring(eodCloseTime, 2, 4))
currentHour = hour(time, 'UTC')
currentMinute = minute(time, 'UTC')

// Check if we've reached or passed EOD close time
isEODCloseTime = enableEODClose and (currentHour > eodHour or (currentHour == eodHour and currentMinute >= eodMinute))

// Prevent entries within 30 minutes before EOD close
tooCloseToEOD = enableEODClose and currentHour == eodHour and currentMinute >= (eodMinute - 30)

// === Choppy Hours Check ===
isChoppyHour = enableChoppyFilter and currentHour >= choppyStartHour and currentHour < choppyEndHour

// === Volume Calculations ===
volumeMA = ta.sma(volume, volumeMALength)
volumeCondition = volume >= volumeMultiplier * volumeMA

// === ATR Volatility Calculations ===
atr = ta.atr(atrLength)
atrCondition = not enableATRFilter or atr >= minATR

// === Trend Filter Calculations ===
trendEMA = ta.ema(close, trendEMALength)
inUptrend = close > trendEMA
inDowntrend = close < trendEMA

// === Consecutive Loss Tracking ===
var int consecutiveLosses = 0
var float lastNetProfit = 0.0
var int barsSinceMaxLosses = 0

// Update consecutive losses after position closes
if strategy.position_size == 0 and strategy.position_size[1] != 0
    if strategy.netprofit < lastNetProfit
        consecutiveLosses := consecutiveLosses + 1
    else
        consecutiveLosses := 0
    lastNetProfit := strategy.netprofit

// Cooldown reset: If we hit max losses, count bars and reset after cooldown
if enableLossFilter and consecutiveLosses >= maxConsecutiveLosses
    barsSinceMaxLosses := barsSinceMaxLosses + 1
    if barsSinceMaxLosses >= lossFilterCooldownBars
        // Reset after cooldown period
        consecutiveLosses := 0
        barsSinceMaxLosses := 0
else
    barsSinceMaxLosses := 0

// Check if we're allowed to trade (not over loss limit)
allowedToTrade = not enableLossFilter or consecutiveLosses < maxConsecutiveLosses

// === Candle Calculations ===
candleRange = high - low
candleIsBullish = close > open
candleIsBearish = close < open

// === Trigger Candle Conditions ===
validCandleRange = candleRange >= minCandleRange and candleRange <= maxCandleRange

// Apply trend filter if enabled
trendAllowsLong = not enableTrendFilter or inUptrend
trendAllowsShort = not enableTrendFilter or inDowntrend

triggerLong = is5min and candleIsBullish and volumeCondition and validCandleRange and inTradingWindow and trendAllowsLong and not isChoppyHour and not tooCloseToEOD and atrCondition and allowedToTrade
triggerShort = is5min and candleIsBearish and volumeCondition and validCandleRange and inTradingWindow and trendAllowsShort and not isChoppyHour and not tooCloseToEOD and atrCondition and allowedToTrade

// === Debug Failed Conditions ===
if showFailedConditions and strategy.position_size == 0
    // Check if we have a potential signal but missing one condition
    potentialLong = candleIsBullish and (volumeCondition or validCandleRange or is5min or inTradingWindow)
    potentialShort = candleIsBearish and (volumeCondition or validCandleRange or is5min or inTradingWindow)

    if potentialLong and not triggerLong
        debugText = 'âš ï¸ LONG SIGNAL FAILED:\n'
        debugText := debugText + 'Timeframe: ' + (is5min ? 'âœ“' : 'âœ— NOT 5min') + '\n'
        debugText := debugText + 'Bullish: ' + (candleIsBullish ? 'âœ“' : 'âœ—') + '\n'
        debugText := debugText + 'Volume: ' + (volumeCondition ? 'âœ“' : 'âœ— ' + str.tostring(volume/volumeMA, '#.##') + 'x MA') + '\n'
        debugText := debugText + 'Range: ' + (validCandleRange ? 'âœ“' : 'âœ— ' + str.tostring(candleRange, '#.##') + ' pts') + '\n'
        debugText := debugText + 'Min: ' + str.tostring(minCandleRange, '#.#') + ' Max: ' + str.tostring(maxCandleRange, '#.#') + '\n'
        debugText := debugText + 'Trend: ' + (trendAllowsLong ? 'âœ“' : 'âœ— Below EMA') + '\n'
        debugText := debugText + 'ATR: ' + (atrCondition ? 'âœ“' : 'âœ— ATR=' + str.tostring(atr, '#.#')) + '\n'
        debugText := debugText + 'Losses: ' + (allowedToTrade ? 'âœ“' : 'âœ— ' + str.tostring(consecutiveLosses) + ' in row') + '\n'
        debugText := debugText + 'Choppy: ' + (not isChoppyHour ? 'âœ“' : 'âœ— Choppy hours') + '\n'
        debugText := debugText + 'EOD: ' + (not tooCloseToEOD ? 'âœ“' : 'âœ— Too close to EOD') + '\n'
        debugText := debugText + 'Time: ' + (inTradingWindow ? 'âœ“' : 'âœ— Outside hours')
        label.new(bar_index, high, debugText, style=label.style_label_down, color=color.new(color.orange, 0), textcolor=color.black, size=size.tiny)

    if potentialShort and not triggerShort
        debugText = 'âš ï¸ SHORT SIGNAL FAILED:\n'
        debugText := debugText + 'Timeframe: ' + (is5min ? 'âœ“' : 'âœ— NOT 5min') + '\n'
        debugText := debugText + 'Bearish: ' + (candleIsBearish ? 'âœ“' : 'âœ—') + '\n'
        debugText := debugText + 'Volume: ' + (volumeCondition ? 'âœ“' : 'âœ— ' + str.tostring(volume/volumeMA, '#.##') + 'x MA') + '\n'
        debugText := debugText + 'Range: ' + (validCandleRange ? 'âœ“ ' : 'âœ— ' + str.tostring(candleRange, '#.##') + ' pts') + '\n'
        debugText := debugText + 'Min: ' + str.tostring(minCandleRange, '#.#') + ' Max: ' + str.tostring(maxCandleRange, '#.#') + '\n'
        debugText := debugText + 'Trend: ' + (trendAllowsShort ? 'âœ“' : 'âœ— Above EMA') + '\n'
        debugText := debugText + 'ATR: ' + (atrCondition ? 'âœ“' : 'âœ— ATR=' + str.tostring(atr, '#.#')) + '\n'
        debugText := debugText + 'Losses: ' + (allowedToTrade ? 'âœ“' : 'âœ— ' + str.tostring(consecutiveLosses) + ' in row') + '\n'
        debugText := debugText + 'Choppy: ' + (not isChoppyHour ? 'âœ“' : 'âœ— Choppy hours') + '\n'
        debugText := debugText + 'EOD: ' + (not tooCloseToEOD ? 'âœ“' : 'âœ— Too close to EOD') + '\n'
        debugText := debugText + 'Time: ' + (inTradingWindow ? 'âœ“' : 'âœ— Outside hours')
        label.new(bar_index, low, debugText, style=label.style_label_up, color=color.new(color.orange, 0), textcolor=color.black, size=size.tiny)

// === Track Position State ===
var float entryPrice = na
var float currentStopLoss = na
var float takeProfitLevel = na
var float initialCandleSize = na  // Size of the entry trigger candle
var int tradeDirection = 0  // 1 = long, -1 = short, 0 = no position
var bool tpHit = false  // Whether we've hit TP and scaled out
var float highestPrice = na  // Track highest price for trailing (long)
var float lowestPrice = na  // Track lowest price for trailing (short)

// === Entry Logic ===
// Long entry (2 contracts only, no pyramiding)
if triggerLong and strategy.position_size == 0
    entryPrice := close
    currentStopLoss := low
    initialCandleSize := candleRange  // Track the entry candle size
    tradeDirection := 1
    tpHit := false
    highestPrice := close

    // Calculate take profit based on stop distance and ratio
    stopDistance = entryPrice - currentStopLoss
    takeProfitLevel := entryPrice + (stopDistance * tpRatio)

    strategy.entry('Long', strategy.long, qty=2)

    if showDebugLabels
        label.new(bar_index, high, 'ðŸŸ¢ LONG ENTRY\nEntry: ' + str.tostring(entryPrice, format.mintick) + '\nSL: ' + str.tostring(currentStopLoss, format.mintick) + '\nTP: ' + str.tostring(takeProfitLevel, format.mintick),
                  style=label.style_label_down, color=color.green, textcolor=color.white, size=size.small)

// Short entry (2 contracts only, no pyramiding)
if triggerShort and strategy.position_size == 0
    entryPrice := close
    currentStopLoss := high
    initialCandleSize := candleRange  // Track the entry candle size
    tradeDirection := -1
    tpHit := false
    lowestPrice := close

    // Calculate take profit based on stop distance and ratio
    stopDistance = currentStopLoss - entryPrice
    takeProfitLevel := entryPrice - (stopDistance * tpRatio)

    strategy.entry('Short', strategy.short, qty=2)

    if showDebugLabels
        label.new(bar_index, low, 'ðŸ”´ SHORT ENTRY\nEntry: ' + str.tostring(entryPrice, format.mintick) + '\nSL: ' + str.tostring(currentStopLoss, format.mintick) + '\nTP: ' + str.tostring(takeProfitLevel, format.mintick),
                  style=label.style_label_up, color=color.red, textcolor=color.white, size=size.small)

// === Take Profit & Trailing Stop Management ===
// Long position management
if strategy.position_size > 0 and tradeDirection == 1
    // Update highest price reached
    if high > highestPrice
        highestPrice := high

    // Check if we hit take profit and haven't scaled out yet
    if enableFixedTP and high >= takeProfitLevel and not tpHit
        // Scale out at TP
        scaleOutQty = math.round(math.abs(strategy.position_size) * (scaleOutPercent / 100.0))
        strategy.close('Long', qty=scaleOutQty, comment='TP 3:1')
        tpHit := true

        if showDebugLabels
            label.new(bar_index, high, 'ðŸ’° TAKE PROFIT\n' + str.tostring(scaleOutPercent, '#') + '% @ ' + str.tostring(takeProfitLevel, format.mintick),
                      style=label.style_label_down, color=color.new(color.yellow, 0), textcolor=color.black, size=size.small)

    // Trail stop using initial candle size as increment
    // Once price moves up by one candle size, move stop up by one candle size
    if tpHit
        // After TP hit, trail aggressively
        priceMovement = highestPrice - entryPrice
        numCandleSizes = math.floor(priceMovement / initialCandleSize)

        if numCandleSizes > 0
            newStopLoss = entryPrice + ((numCandleSizes - 1) * initialCandleSize) + tickOffset  // Add offset to cover fees
            if newStopLoss > currentStopLoss
                currentStopLoss := newStopLoss
                if showDebugLabels
                    label.new(bar_index, low, 'ðŸ“ˆ Trail\nSL: ' + str.tostring(currentStopLoss, format.mintick),
                              style=label.style_label_up, color=color.aqua, textcolor=color.black, size=size.tiny)

    // Apply exit order
    if enableFixedTP and not tpHit
        strategy.exit('Long Exit', 'Long', stop=currentStopLoss, limit=takeProfitLevel)
    else
        strategy.exit('Long Exit', 'Long', stop=currentStopLoss)

// Short position management
if strategy.position_size < 0 and tradeDirection == -1
    // Update lowest price reached
    if low < lowestPrice
        lowestPrice := low

    // Check if we hit take profit and haven't scaled out yet
    if enableFixedTP and low <= takeProfitLevel and not tpHit
        // Scale out at TP
        scaleOutQty = math.round(math.abs(strategy.position_size) * (scaleOutPercent / 100.0))
        strategy.close('Short', qty=scaleOutQty, comment='TP 3:1')
        tpHit := true

        if showDebugLabels
            label.new(bar_index, low, 'ðŸ’° TAKE PROFIT\n' + str.tostring(scaleOutPercent, '#') + '% @ ' + str.tostring(takeProfitLevel, format.mintick),
                      style=label.style_label_up, color=color.new(color.yellow, 0), textcolor=color.black, size=size.small)

    // Trail stop using initial candle size as increment
    if tpHit
        // After TP hit, trail aggressively
        priceMovement = entryPrice - lowestPrice
        numCandleSizes = math.floor(priceMovement / initialCandleSize)

        if numCandleSizes > 0
            newStopLoss = entryPrice - ((numCandleSizes - 1) * initialCandleSize) - tickOffset  // Subtract offset to cover fees
            if newStopLoss < currentStopLoss
                currentStopLoss := newStopLoss
                if showDebugLabels
                    label.new(bar_index, high, 'ðŸ“‰ Trail\nSL: ' + str.tostring(currentStopLoss, format.mintick),
                              style=label.style_label_down, color=color.orange, textcolor=color.black, size=size.tiny)

    // Apply exit order
    if enableFixedTP and not tpHit
        strategy.exit('Short Exit', 'Short', stop=currentStopLoss, limit=takeProfitLevel)
    else
        strategy.exit('Short Exit', 'Short', stop=currentStopLoss)

// === Close Positions Outside Trading Hours ===
if closeOutsideHours and not inTradingWindow
    if strategy.position_size > 0
        strategy.close('Long', comment='Outside Trading Hours')
    if strategy.position_size < 0
        strategy.close('Short', comment='Outside Trading Hours')

// === End of Day Close ===
if isEODCloseTime
    if strategy.position_size > 0
        strategy.close('Long', comment='EOD Close 21:00 UTC')
        if showDebugLabels
            label.new(bar_index, high, 'ðŸ”” EOD CLOSE\n21:00 UTC', style=label.style_label_down, color=color.new(color.purple, 0), textcolor=color.white, size=size.small)
    if strategy.position_size < 0
        strategy.close('Short', comment='EOD Close 21:00 UTC')
        if showDebugLabels
            label.new(bar_index, low, 'ðŸ”” EOD CLOSE\n21:00 UTC', style=label.style_label_up, color=color.new(color.purple, 0), textcolor=color.white, size=size.small)

// === Reset on Position Close ===
if strategy.position_size == 0 and strategy.position_size[1] != 0
    entryPrice := na
    currentStopLoss := na
    takeProfitLevel := na
    initialCandleSize := na
    tradeDirection := 0
    tpHit := false
    highestPrice := na
    lowestPrice := na

// === Visual Reference ===
// Plot entry signals
plotshape(triggerLong, title='Long Trigger', style=shape.triangleup, location=location.belowbar, color=color.new(color.green, 0), size=size.small)
plotshape(triggerShort, title='Short Trigger', style=shape.triangledown, location=location.abovebar, color=color.new(color.red, 0), size=size.small)

// Plot stop loss line
plot(strategy.position_size != 0 ? currentStopLoss : na, title='Stop Loss', color=color.red, linewidth=2, style=plot.style_linebr)

// Plot take profit line
plot(strategy.position_size != 0 and enableFixedTP and not tpHit ? takeProfitLevel : na, title='Take Profit', color=color.new(color.yellow, 0), linewidth=2, style=plot.style_linebr)

// Plot trend EMA
plot(enableTrendFilter ? trendEMA : na, title='Trend EMA', color=color.new(color.yellow, 0), linewidth=2)

// === Volume Reference ===
bgcolor(volumeCondition ? color.new(color.blue, 95) : na, title='High Volume Background')

// === Warning: Trading Paused ===
bgcolor(not allowedToTrade ? color.new(color.red, 80) : na, title='Trading Paused - Consecutive Losses')

// Plot ATR for reference
plot(enableATRFilter ? atr : na, title='ATR', color=color.new(color.orange, 0), linewidth=1)
