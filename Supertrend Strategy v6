//@version=6
// DISCLAIMER: This strategy is provided "as is" for educational and backtesting purposes only. BucksTRDR is not responsible for trading decisions made using this tool. Always do your own research and consult a financial professional.
strategy('Supertrend Strategy by BucksTRDR', overlay=true,
         fill_orders_on_standard_ohlc=true,
         calc_on_every_tick=true,
         calc_on_order_fills=true,
         initial_capital=100000,
         default_qty_type=strategy.percent_of_equity,
         default_qty_value=100,
         commission_type=strategy.commission.percent,
         commission_value=0.1,
         pyramiding=0)

// === Inputs ===
Periods = input.int(title='ATR Period', defval=10, minval=1, group='Supertrend Settings', tooltip='Period for ATR calculation')
src = input(hl2, title='Source', group='Supertrend Settings', tooltip='Price source for calculations')
Multiplier = input.float(title='ATR Multiplier', step=0.1, defval=3.0, minval=0.1, group='Supertrend Settings', tooltip='Multiplier for ATR bands')
changeATR = input.bool(title='Change ATR Calculation Method?', defval=true, group='Supertrend Settings', tooltip='Use built-in ATR vs SMA of TR')
showsignals = input.bool(title='Show Buy/Sell Signals?', defval=true, group='Display', tooltip='Show buy/sell labels on chart')
highlighting = input.bool(title='Highlighter On/Off?', defval=true, group='Display', tooltip='Highlight trend direction with fills')
showDetailedLabels = input.bool(title='Show Detailed Entry Labels?', defval=false, group='Display', tooltip='Show detailed entry/SL/TP info labels (can clutter chart)')

// === Strategy Settings ===
useTakeProfit = input.bool(title='Use Take Profit', defval=true, group='Risk Management', tooltip='Enable RR-based take profit')
riskRewardRatio = input.float(title='Risk:Reward Ratio', defval=2.0, minval=0.5, step=0.5, group='Risk Management', tooltip='Risk-reward ratio for take profit (e.g., 2.0 = 2:1)')
lookbackCandles = input.int(title='Stop Loss Lookback Candles', defval=3, minval=1, maxval=10, group='Risk Management', tooltip='Number of previous candles to find highest/lowest for stop loss')
feeOffset = input.float(title='Break-Even Fee Offset (points)', defval=0.5, minval=0, step=0.1, group='Risk Management', tooltip='Offset in points for break-even stop to cover commissions (0.5 = $5 on MGC)')

// === Consecutive Loss Filter ===
enableLossFilter = input.bool(title='Enable Consecutive Loss Filter', defval=false, group='Filters', tooltip='Stop trading after consecutive losses (DISABLED by default due to issues)')
maxConsecutiveLosses = input.int(title='Max Consecutive Losses', defval=3, minval=1, maxval=10, group='Filters', tooltip='Stop trading after this many losses in a row')
lossFilterCooldownBars = input.int(title='Cooldown Bars After Max Losses', defval=20, minval=1, maxval=200, group='Filters', tooltip='Number of bars to wait before resetting after max losses hit')

// === ADX Trend Strength Filter ===
enableADXFilter = input.bool(title='Enable ADX Trend Filter', defval=true, group='Filters', tooltip='Only trade when trend is strong enough')
adxLength = input.int(title='ADX Length', defval=14, minval=1, group='Filters', tooltip='Length for ADX calculation')
minADX = input.float(title='Min ADX for Entry', defval=20.0, minval=1.0, step=1.0, group='Filters', tooltip='Minimum ADX value to enter trades (20-25 recommended)')

// === Momentum Filter ===
enableMomentumFilter = input.bool(title='Enable Momentum Filter', defval=true, group='Filters', tooltip='Require minimum price move from Supertrend line')
minMovePercent = input.float(title='Min % Move from ST Line', defval=0.5, minval=0.1, step=0.1, group='Filters', tooltip='Minimum % move from Supertrend line to confirm momentum')

// === End of Day Close ===
enableEODClose = input.bool(title='Enable End of Day Close', defval=true, group='Time Filter', tooltip='Close all positions at specific time')
eodCloseTime = input.string('2100', title='EOD Close Time (UTC)', group='Time Filter', tooltip='Time to close all positions (24hr format, e.g. 2100 for 9pm UTC)')

// Parse EOD time
eodHour = str.tonumber(str.substring(eodCloseTime, 0, 2))
eodMinute = str.tonumber(str.substring(eodCloseTime, 2, 4))
currentHour = hour(time, 'UTC')
currentMinute = minute(time, 'UTC')

// Check if we've reached or passed EOD close time
isEODCloseTime = enableEODClose and (currentHour > eodHour or (currentHour == eodHour and currentMinute >= eodMinute))

// Prevent entries within 30 minutes before EOD close
tooCloseToEOD = enableEODClose and currentHour == eodHour and currentMinute >= (eodMinute - 30)

// === ATR Calculation ===
atr2 = ta.sma(ta.tr, Periods)
atr = changeATR ? ta.atr(Periods) : atr2

// === Supertrend Calculation ===
up = src - Multiplier * atr
up1 = nz(up[1], up)
up := close[1] > up1 ? math.max(up, up1) : up

dn = src + Multiplier * atr
dn1 = nz(dn[1], dn)
dn := close[1] < dn1 ? math.min(dn, dn1) : dn

trend = 1
trend := nz(trend[1], trend)
trend := trend == -1 and close > dn1 ? 1 : trend == 1 and close < up1 ? -1 : trend

// === ADX Calculation ===
[diPlus, diMinus, adx] = ta.dmi(adxLength, adxLength)
adxCondition = not enableADXFilter or adx >= minADX

// === Momentum Filter Calculation ===
// Calculate % distance from Supertrend line
priceAboveUp = ((close - up) / up) * 100
priceBelowDn = ((dn - close) / dn) * 100

momentumLongOK = not enableMomentumFilter or priceAboveUp >= minMovePercent
momentumShortOK = not enableMomentumFilter or priceBelowDn >= minMovePercent

// === Consecutive Loss Tracking ===
var int consecutiveLosses = 0
var float lastNetProfit = 0.0
var int barsSinceMaxLosses = 0

// Update consecutive losses after position closes
if strategy.position_size == 0 and strategy.position_size[1] != 0
    if strategy.netprofit < lastNetProfit
        consecutiveLosses := consecutiveLosses + 1
    else
        consecutiveLosses := 0
    lastNetProfit := strategy.netprofit

// Cooldown reset: If we hit max losses, count bars and reset after cooldown
if enableLossFilter and consecutiveLosses >= maxConsecutiveLosses
    barsSinceMaxLosses := barsSinceMaxLosses + 1
    if barsSinceMaxLosses >= lossFilterCooldownBars
        // Reset after cooldown period
        consecutiveLosses := 0
        barsSinceMaxLosses := 0
else
    barsSinceMaxLosses := 0

// Check if we're allowed to trade (not over loss limit)
allowedToTrade = not enableLossFilter or consecutiveLosses < maxConsecutiveLosses

// === Signals ===
// Only generate signals when flat (no open position) and all filters pass
buySignal = trend == 1 and trend[1] == -1 and strategy.position_size == 0 and not tooCloseToEOD and adxCondition and momentumLongOK and allowedToTrade
sellSignal = trend == -1 and trend[1] == 1 and strategy.position_size == 0 and not tooCloseToEOD and adxCondition and momentumShortOK and allowedToTrade

// === Track Entry Price and Initial Stop ===
var float entryPrice = na
var float initialStop = na
var float takeProfit = na
var float riskAmount = na

// === Strategy Logic ===
// Long Entry: When Supertrend flips to bullish
if buySignal
    entryPrice := close
    // Find the lowest low of previous N candles for stop loss
    initialStop := ta.lowest(low, lookbackCandles)[1]  // [1] to skip current candle

    // Calculate risk and take profit
    riskAmount := entryPrice - initialStop
    takeProfit := entryPrice + (riskAmount * riskRewardRatio)

    strategy.entry('Long', strategy.long, comment='Long Entry')

    if showDetailedLabels
        debugText = 'ðŸŸ¢ LONG\nEntry: ' + str.tostring(entryPrice, format.mintick) + '\nSL: ' + str.tostring(initialStop, format.mintick) + '\nTP: ' + str.tostring(takeProfit, format.mintick) + '\nRR: ' + str.tostring(riskRewardRatio, '#.#') + ':1'
        label.new(bar_index, low, debugText, style=label.style_label_up, color=color.new(color.green, 0), textcolor=color.white, size=size.tiny)

// Short Entry: When Supertrend flips to bearish
if sellSignal
    entryPrice := close
    // Find the highest high of previous N candles for stop loss
    initialStop := ta.highest(high, lookbackCandles)[1]  // [1] to skip current candle

    // Calculate risk and take profit
    riskAmount := initialStop - entryPrice
    takeProfit := entryPrice - (riskAmount * riskRewardRatio)

    strategy.entry('Short', strategy.short, comment='Short Entry')

    if showDetailedLabels
        debugText = 'ðŸ”´ SHORT\nEntry: ' + str.tostring(entryPrice, format.mintick) + '\nSL: ' + str.tostring(initialStop, format.mintick) + '\nTP: ' + str.tostring(takeProfit, format.mintick) + '\nRR: ' + str.tostring(riskRewardRatio, '#.#') + ':1'
        label.new(bar_index, high, debugText, style=label.style_label_down, color=color.new(color.red, 0), textcolor=color.white, size=size.tiny)

// === RR-Based Trailing Stop Management ===
// Long position management
if strategy.position_size > 0
    // Calculate current profit in R's
    currentProfit = close - entryPrice
    currentRR = currentProfit / riskAmount

    // Trail stop based on RR achieved:
    // At 1R, go break even. At 2R, trail to 1R profit. At 3R, trail to 2R profit, etc.
    trailingStop = initialStop
    if currentRR >= 1.0
        // Move to break even at 1R
        rrLevel = math.floor(currentRR)
        trailingStop := entryPrice + ((rrLevel - 1) * riskAmount) + feeOffset  // Add offset to cover fees

    if useTakeProfit
        strategy.exit('Long Exit', 'Long', stop=trailingStop, limit=takeProfit)
    else
        strategy.exit('Long Exit', 'Long', stop=trailingStop)

// Short position management
if strategy.position_size < 0
    // Calculate current profit in R's
    currentProfit = entryPrice - close
    currentRR = currentProfit / riskAmount

    // Trail stop based on RR achieved:
    // At 1R, go break even. At 2R, trail to 1R profit. At 3R, trail to 2R profit, etc.
    trailingStop = initialStop
    if currentRR >= 1.0
        // Move to break even at 1R
        rrLevel = math.floor(currentRR)
        trailingStop := entryPrice - ((rrLevel - 1) * riskAmount) - feeOffset  // Subtract offset to cover fees

    if useTakeProfit
        strategy.exit('Short Exit', 'Short', stop=trailingStop, limit=takeProfit)
    else
        strategy.exit('Short Exit', 'Short', stop=trailingStop)

// === End of Day Close ===
if isEODCloseTime
    if strategy.position_size > 0
        strategy.close('Long', comment='EOD Close 21:00 UTC')
        if showDetailedLabels
            label.new(bar_index, high, 'EOD', style=label.style_label_down, color=color.new(color.purple, 0), textcolor=color.white, size=size.tiny)
    if strategy.position_size < 0
        strategy.close('Short', comment='EOD Close 21:00 UTC')
        if showDetailedLabels
            label.new(bar_index, low, 'EOD', style=label.style_label_up, color=color.new(color.purple, 0), textcolor=color.white, size=size.tiny)

// Reset on position close
if strategy.position_size == 0 and strategy.position_size[1] != 0
    entryPrice := na
    initialStop := na
    takeProfit := na
    riskAmount := na

// === Visual Elements ===
upPlot = plot(trend == 1 ? up : na, title='Up Trend', style=plot.style_linebr, linewidth=2, color=color.green)
plotshape(buySignal ? up : na, title='UpTrend Begins', location=location.absolute, style=shape.circle, size=size.tiny, color=color.new(color.green, 0))
plotshape(buySignal and showsignals ? up : na, title='Buy', text='Buy', location=location.absolute, style=shape.labelup, size=size.tiny, color=color.new(color.green, 0), textcolor=color.white)

dnPlot = plot(trend == 1 ? na : dn, title='Down Trend', style=plot.style_linebr, linewidth=2, color=color.red)
plotshape(sellSignal ? dn : na, title='DownTrend Begins', location=location.absolute, style=shape.circle, size=size.tiny, color=color.new(color.red, 0))
plotshape(sellSignal and showsignals ? dn : na, title='Sell', text='Sell', location=location.absolute, style=shape.labeldown, size=size.tiny, color=color.new(color.red, 0), textcolor=color.white)

// Calculate current trailing stop for display
var float displayStop = na
if strategy.position_size > 0
    currentProfit = close - entryPrice
    currentRR = currentProfit / riskAmount
    displayStop := initialStop
    if currentRR >= 1.0
        rrLevel = math.floor(currentRR)
        displayStop := entryPrice + ((rrLevel - 1) * riskAmount) + feeOffset
else if strategy.position_size < 0
    currentProfit = entryPrice - close
    currentRR = currentProfit / riskAmount
    displayStop := initialStop
    if currentRR >= 1.0
        rrLevel = math.floor(currentRR)
        displayStop := entryPrice - ((rrLevel - 1) * riskAmount) - feeOffset
else
    displayStop := na

// Plot stop loss and take profit levels
plot(strategy.position_size != 0 and not na(takeProfit) ? takeProfit : na, title='Take Profit', color=color.new(color.yellow, 0), linewidth=2, style=plot.style_linebr)
plot(strategy.position_size != 0 and not na(displayStop) ? displayStop : na, title='Trailing Stop', color=color.new(color.red, 0), linewidth=2, style=plot.style_linebr)

// Plot ADX for reference (on separate pane)
hline(minADX, 'Min ADX Level', color=color.new(color.orange, 50), linestyle=hline.style_dashed)
plot(enableADXFilter ? adx : na, title='ADX', color=color.new(color.blue, 0), linewidth=2)

// Background color when trading is paused
bgcolor(not allowedToTrade ? color.new(color.red, 85) : na, title='Trading Paused - Consecutive Losses')

mPlot = plot(ohlc4, title='', style=plot.style_circles, linewidth=0, display=display.none)

longFillColor = highlighting ? (trend == 1 ? color.new(color.green, 90) : color.new(color.white, 100)) : color.new(color.white, 100)
shortFillColor = highlighting ? (trend == -1 ? color.new(color.red, 90) : color.new(color.white, 100)) : color.new(color.white, 100)

fill(mPlot, upPlot, title='UpTrend Highlighter', color=longFillColor)
fill(mPlot, dnPlot, title='DownTrend Highlighter', color=shortFillColor)

// === Alerts ===
alertcondition(buySignal, title='SuperTrend Buy', message='SuperTrend Buy!')
alertcondition(sellSignal, title='SuperTrend Sell', message='SuperTrend Sell!')
changeCond = trend != trend[1]
alertcondition(changeCond, title='SuperTrend Direction Change', message='SuperTrend has changed direction!')
