//@version=6
// DISCLAIMER: This strategy is provided "as is" for educational purposes only. BucksTRDR is not responsible for trading decisions made using this tool. Always do your own research and consult a financial professional.
strategy('ORB Multi-Session Strategy by BucksTRDR', overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, pyramiding=0, calc_on_every_tick=false, calc_on_order_fills=false)

// === Strategy Settings ===
stopLossMultiplier = input.float(1.0, title='Stop Loss Multiplier', minval=0.1, step=0.1, tooltip='Stop loss as multiple of OR range (e.g., 1.0 = 1x range)')
maxTradesPerSession = input.int(1, title='Max Trades Per Session', minval=1, maxval=10, tooltip='Maximum number of trades allowed per session')

// === ORB Settings ===
orbTotalTime = input.int(5, title='ORB total time (minutes)')

// === Volume Confirmation ===
volumeMALength = input.int(20, title='Volume MA Length', minval=1)
volumeMultiplier = input.float(1.5, title='Volume Multiplier', minval=0.1, step=0.1)
breakoutPercent = input.float(25.0, title='Minimum Breakout %', minval=1.0, step=1.0)

// === Rubber Band Settings ===
enableRubberBand = input.bool(true, title='Enable Rubber Band Signals')
rbVolumeMultiplier = input.float(1.2, title='Rubber Band Volume Multiplier', minval=0.1, step=0.1)
rbReversalPercent = input.float(50.0, title='Rubber Band Reversal %', minval=10.0, step=5.0)

// === Timezone Selection ===
user_timezone = input.string("UTC+1", title="Your Timezone", options=["UTC", "UTC+1", "UTC+2", "UTC+3", "UTC+4", "UTC+5", "UTC+6", "UTC+7", "UTC+8", "UTC+9", "UTC+10", "UTC+11", "UTC+12", "UTC-1", "UTC-2", "UTC-3", "UTC-4", "UTC-5", "UTC-6", "UTC-7", "UTC-8", "UTC-9", "UTC-10", "UTC-11", "UTC-12"])

// === Session Configuration ===
sess1Enable = input.bool(true, title='Enable Session 1')
sess1 = input.session('0800-0805', title='Session 1 Time (Your Local Time)')
sess1Label = input.string('London OR', title='Session 1 Label')

sess2Enable = input.bool(true, title='Enable Session 2')
sess2 = input.session('1430-1535', title='Session 2 Time (Your Local Time)')
sess2Label = input.string('New York OR', title='Session 2 Label')

sess3Enable = input.bool(true, title='Enable Session 3')
sess3 = input.session('0100-0105', title='Session 3 Time (Your Local Time)')
sess3Label = input.string('Asia OR', title='Session 3 Label')

// === Take Profit Multipliers ===
tp1Multiplier = input.float(1.0, title='TP1 Multiplier', minval=0.1, step=0.1)
tp2Multiplier = input.float(2.0, title='TP2 Multiplier', minval=0.1, step=0.1)
tp3Multiplier = input.float(3.0, title='TP3 Multiplier', minval=0.1, step=0.1)

// === Session Timing Logic ===
time1 = sess1Enable ? time(timeframe.period, sess1 + ':1234567', user_timezone) : na
in_session1 = not na(time1)
is_first1 = in_session1 and not in_session1[1]
time1_end = time(timeframe.period, sess2 + ':1234567', user_timezone)
is_end1 = not na(time1_end) and na(time1_end[1])

time2 = sess2Enable ? time(timeframe.period, sess2 + ':1234567', user_timezone) : na
in_session2 = not na(time2)
is_first2 = in_session2 and not in_session2[1]
time2_end = time(timeframe.period, sess3 + ':1234567', user_timezone)
is_end2 = not na(time2_end) and na(time2_end[1])

time3 = sess3Enable ? time(timeframe.period, sess3 + ':1234567', user_timezone) : na
in_session3 = not na(time3)
is_first3 = in_session3 and not in_session3[1]
time3_end = time(timeframe.period, '1600-1601:1234567', user_timezone)
is_end3 = not na(time3_end) and na(time3_end[1])

// === ORB Storage ===
var float orb_high1 = na
var float orb_low1 = na
var float orb_high2 = na
var float orb_low2 = na
var float orb_high3 = na
var float orb_low3 = na

// === Session Display Flags ===
var bool show1 = false
var bool show2 = false
var bool show3 = false

// === Trade Counter Per Session ===
var int session1TradeCount = 0
var int session2TradeCount = 0
var int session3TradeCount = 0

// === Position Tracking for Stop Management ===
var float entryPrice = na
var float tp2Level = na
var float tp3Level = na
var bool tp2Reached = false
var string currentTradeID = ""
var float highestHigh = na  // Track highest price for long trailing
var float lowestLow = na    // Track lowest price for short trailing

// === ORB Calculation ===
if sess1Enable
    if is_first1
        orb_high1 := high
        orb_low1 := low
        session1TradeCount := 0  // Reset trade counter
    else
        orb_high1 := orb_high1[1]
        orb_low1 := orb_low1[1]
    if in_session1
        orb_high1 := math.max(orb_high1, high)
        orb_low1 := math.min(orb_low1, low)

if sess2Enable
    if is_first2
        orb_high2 := high
        orb_low2 := low
        session2TradeCount := 0  // Reset trade counter
    else
        orb_high2 := orb_high2[1]
        orb_low2 := orb_low2[1]
    if in_session2
        orb_high2 := math.max(orb_high2, high)
        orb_low2 := math.min(orb_low2, low)

if sess3Enable
    if is_first3
        orb_high3 := high
        orb_low3 := low
        session3TradeCount := 0  // Reset trade counter
    else
        orb_high3 := orb_high3[1]
        orb_low3 := orb_low3[1]
    if in_session3
        orb_high3 := math.max(orb_high3, high)
        orb_low3 := math.min(orb_low3, low)

// === Deltas ===
delta1 = orb_high1 - orb_low1
delta2 = orb_high2 - orb_low2
delta3 = orb_high3 - orb_low3

// === Volume Calculations ===
volumeMA = ta.sma(volume, volumeMALength)
volumeCondition = volume >= volumeMultiplier * volumeMA
breakoutThreshold = breakoutPercent / 100.0

// === Session Display Management ===
if sess1Enable and is_first1
    show1 := true
    show2 := false
    show3 := false
else if sess2Enable and is_first2
    show1 := false
    show2 := true
    show3 := false
else if sess3Enable and is_first3
    show1 := false
    show2 := false
    show3 := true

// Handle session end conditions
if is_end1 and show1
    show1 := false
if is_end2 and show2
    show2 := false
if is_end3 and show3
    show3 := false

// === Trade Signals ===
is5min = timeframe.isintraday and timeframe.multiplier == 5

// Session 1 signals
long1Breakout = (close - orb_high1) >= (breakoutThreshold * delta1)
short1Breakout = (orb_low1 - close) >= (breakoutThreshold * delta1)
long1Basic = is5min and show1 and open < orb_high1 and close > orb_high1
short1Basic = is5min and show1 and open > orb_low1 and close < orb_low1
long1 = long1Basic and volumeCondition and long1Breakout and session1TradeCount < maxTradesPerSession
short1 = short1Basic and volumeCondition and short1Breakout and session1TradeCount < maxTradesPerSession

// Session 2 signals
long2Breakout = (close - orb_high2) >= (breakoutThreshold * delta2)
short2Breakout = (orb_low2 - close) >= (breakoutThreshold * delta2)
long2Basic = is5min and show2 and open < orb_high2 and close > orb_high2
short2Basic = is5min and show2 and open > orb_low2 and close < orb_low2
long2 = long2Basic and volumeCondition and long2Breakout and session2TradeCount < maxTradesPerSession
short2 = short2Basic and volumeCondition and short2Breakout and session2TradeCount < maxTradesPerSession

// Session 3 signals
long3Breakout = (close - orb_high3) >= (breakoutThreshold * delta3)
short3Breakout = (orb_low3 - close) >= (breakoutThreshold * delta3)
long3Basic = is5min and show3 and open < orb_high3 and close > orb_high3
short3Basic = is5min and show3 and open > orb_low3 and close < orb_low3
long3 = long3Basic and volumeCondition and long3Breakout and session3TradeCount < maxTradesPerSession
short3 = short3Basic and volumeCondition and short3Breakout and session3TradeCount < maxTradesPerSession

// === Rubber Band Reversal Signals ===
rubberBandLong = false
rubberBandShort = false

if enableRubberBand and is5min and volume >= rbVolumeMultiplier * volumeMA
    prevOrbLong = long1[1] or long2[1] or long3[1]
    prevOrbShort = short1[1] or short2[1] or short3[1]

    if prevOrbLong or prevOrbShort
        prevCandleRange = high[1] - low[1]
        reversalThreshold = rbReversalPercent / 100.0

        if prevCandleRange > 0
            if prevOrbLong
                pullbackAmount = high[1] - close
                if pullbackAmount >= (reversalThreshold * prevCandleRange)
                    // Check trade count for current session
                    canTrade = (show1 and session1TradeCount < maxTradesPerSession) or
                               (show2 and session2TradeCount < maxTradesPerSession) or
                               (show3 and session3TradeCount < maxTradesPerSession)
                    rubberBandShort := canTrade

            if prevOrbShort
                bounceAmount = close - low[1]
                if bounceAmount >= (reversalThreshold * prevCandleRange)
                    // Check trade count for current session
                    canTrade = (show1 and session1TradeCount < maxTradesPerSession) or
                               (show2 and session2TradeCount < maxTradesPerSession) or
                               (show3 and session3TradeCount < maxTradesPerSession)
                    rubberBandLong := canTrade

// === STRATEGY ENTRIES ===

// Entry IDs for tracking
var string LONG1_ID = "Long1"
var string SHORT1_ID = "Short1"
var string LONG2_ID = "Long2"
var string SHORT2_ID = "Short2"
var string LONG3_ID = "Long3"
var string SHORT3_ID = "Short3"
var string RB_LONG_ID = "RB_Long"
var string RB_SHORT_ID = "RB_Short"

// Session 1 entries
if long1
    stopLoss = orb_low1 - (stopLossMultiplier * delta1)
    strategy.entry(LONG1_ID, strategy.long, comment="L1")
    strategy.exit("L1_TP1", from_entry=LONG1_ID, limit=orb_high1 + tp1Multiplier * delta1, stop=stopLoss, qty_percent=33)
    strategy.exit("L1_TP2", from_entry=LONG1_ID, limit=orb_high1 + tp2Multiplier * delta1, stop=stopLoss, qty_percent=33)
    strategy.exit("L1_TP3", from_entry=LONG1_ID, limit=orb_high1 + tp3Multiplier * delta1, stop=stopLoss, qty_percent=34)
    session1TradeCount := session1TradeCount + 1
    // Track position details
    entryPrice := close
    tp2Level := orb_high1 + tp2Multiplier * delta1
    tp3Level := orb_high1 + tp3Multiplier * delta1
    tp2Reached := false
    currentTradeID := LONG1_ID
    highestHigh := high
    lowestLow := na

if short1
    stopLoss = orb_high1 + (stopLossMultiplier * delta1)
    strategy.entry(SHORT1_ID, strategy.short, comment="S1")
    strategy.exit("S1_TP1", from_entry=SHORT1_ID, limit=orb_low1 - tp1Multiplier * delta1, stop=stopLoss, qty_percent=33)
    strategy.exit("S1_TP2", from_entry=SHORT1_ID, limit=orb_low1 - tp2Multiplier * delta1, stop=stopLoss, qty_percent=33)
    strategy.exit("S1_TP3", from_entry=SHORT1_ID, limit=orb_low1 - tp3Multiplier * delta1, stop=stopLoss, qty_percent=34)
    session1TradeCount := session1TradeCount + 1
    // Track position details
    entryPrice := close
    tp2Level := orb_low1 - tp2Multiplier * delta1
    tp3Level := orb_low1 - tp3Multiplier * delta1
    tp2Reached := false
    currentTradeID := SHORT1_ID
    highestHigh := na
    lowestLow := low

// Session 2 entries
if long2
    stopLoss = orb_low2 - (stopLossMultiplier * delta2)
    strategy.entry(LONG2_ID, strategy.long, comment="L2")
    strategy.exit("L2_TP1", from_entry=LONG2_ID, limit=orb_high2 + tp1Multiplier * delta2, stop=stopLoss, qty_percent=33)
    strategy.exit("L2_TP2", from_entry=LONG2_ID, limit=orb_high2 + tp2Multiplier * delta2, stop=stopLoss, qty_percent=33)
    strategy.exit("L2_TP3", from_entry=LONG2_ID, limit=orb_high2 + tp3Multiplier * delta2, stop=stopLoss, qty_percent=34)
    session2TradeCount := session2TradeCount + 1
    // Track position details
    entryPrice := close
    tp2Level := orb_high2 + tp2Multiplier * delta2
    tp3Level := orb_high2 + tp3Multiplier * delta2
    tp2Reached := false
    currentTradeID := LONG2_ID
    highestHigh := high
    lowestLow := na

if short2
    stopLoss = orb_high2 + (stopLossMultiplier * delta2)
    strategy.entry(SHORT2_ID, strategy.short, comment="S2")
    strategy.exit("S2_TP1", from_entry=SHORT2_ID, limit=orb_low2 - tp1Multiplier * delta2, stop=stopLoss, qty_percent=33)
    strategy.exit("S2_TP2", from_entry=SHORT2_ID, limit=orb_low2 - tp2Multiplier * delta2, stop=stopLoss, qty_percent=33)
    strategy.exit("S2_TP3", from_entry=SHORT2_ID, limit=orb_low2 - tp3Multiplier * delta2, stop=stopLoss, qty_percent=34)
    session2TradeCount := session2TradeCount + 1
    // Track position details
    entryPrice := close
    tp2Level := orb_low2 - tp2Multiplier * delta2
    tp3Level := orb_low2 - tp3Multiplier * delta2
    tp2Reached := false
    currentTradeID := SHORT2_ID
    highestHigh := na
    lowestLow := low

// Session 3 entries
if long3
    stopLoss = orb_low3 - (stopLossMultiplier * delta3)
    strategy.entry(LONG3_ID, strategy.long, comment="L3")
    strategy.exit("L3_TP1", from_entry=LONG3_ID, limit=orb_high3 + tp1Multiplier * delta3, stop=stopLoss, qty_percent=33)
    strategy.exit("L3_TP2", from_entry=LONG3_ID, limit=orb_high3 + tp2Multiplier * delta3, stop=stopLoss, qty_percent=33)
    strategy.exit("L3_TP3", from_entry=LONG3_ID, limit=orb_high3 + tp3Multiplier * delta3, stop=stopLoss, qty_percent=34)
    session3TradeCount := session3TradeCount + 1
    // Track position details
    entryPrice := close
    tp2Level := orb_high3 + tp2Multiplier * delta3
    tp3Level := orb_high3 + tp3Multiplier * delta3
    tp2Reached := false
    currentTradeID := LONG3_ID
    highestHigh := high
    lowestLow := na

if short3
    stopLoss = orb_high3 + (stopLossMultiplier * delta3)
    strategy.entry(SHORT3_ID, strategy.short, comment="S3")
    strategy.exit("S3_TP1", from_entry=SHORT3_ID, limit=orb_low3 - tp1Multiplier * delta3, stop=stopLoss, qty_percent=33)
    strategy.exit("S3_TP2", from_entry=SHORT3_ID, limit=orb_low3 - tp2Multiplier * delta3, stop=stopLoss, qty_percent=33)
    strategy.exit("S3_TP3", from_entry=SHORT3_ID, limit=orb_low3 - tp3Multiplier * delta3, stop=stopLoss, qty_percent=34)
    session3TradeCount := session3TradeCount + 1
    // Track position details
    entryPrice := close
    tp2Level := orb_low3 - tp2Multiplier * delta3
    tp3Level := orb_low3 - tp3Multiplier * delta3
    tp2Reached := false
    currentTradeID := SHORT3_ID
    highestHigh := na
    lowestLow := low

// Rubber Band entries (Note: RB trades use simpler TP structure, no trailing)
if rubberBandLong
    currentDelta = show1 ? delta1 : show2 ? delta2 : delta3
    stopLoss = low - (stopLossMultiplier * currentDelta)
    strategy.entry(RB_LONG_ID, strategy.long, comment="RB_L")
    strategy.exit("RB_L_Exit", from_entry=RB_LONG_ID, limit=high + currentDelta, stop=stopLoss)
    // Increment appropriate session counter
    if show1
        session1TradeCount := session1TradeCount + 1
    else if show2
        session2TradeCount := session2TradeCount + 1
    else if show3
        session3TradeCount := session3TradeCount + 1
    // Reset tracking since RB doesn't use trailing
    entryPrice := na
    tp2Level := na
    tp2Reached := false
    currentTradeID := ""

if rubberBandShort
    currentDelta = show1 ? delta1 : show2 ? delta2 : delta3
    stopLoss = high + (stopLossMultiplier * currentDelta)
    strategy.entry(RB_SHORT_ID, strategy.short, comment="RB_S")
    strategy.exit("RB_S_Exit", from_entry=RB_SHORT_ID, limit=low - currentDelta, stop=stopLoss)
    // Increment appropriate session counter
    if show1
        session1TradeCount := session1TradeCount + 1
    else if show2
        session2TradeCount := session2TradeCount + 1
    else if show3
        session3TradeCount := session3TradeCount + 1
    // Reset tracking since RB doesn't use trailing
    entryPrice := na
    tp2Level := na
    tp2Reached := false
    currentTradeID := ""

// === DYNAMIC STOP MANAGEMENT ===
// Move to break-even when TP2 is hit, then trail toward TP3
if strategy.position_size != 0 and not na(entryPrice) and not na(tp2Level)
    isLong = strategy.position_size > 0
    isShort = strategy.position_size < 0

    // Check if TP2 has been reached
    if not tp2Reached
        if (isLong and high >= tp2Level) or (isShort and low <= tp2Level)
            tp2Reached := true

    // Update stops dynamically after TP2 is reached
    if tp2Reached
        // Track highest/lowest since TP2 reached
        if isLong
            highestHigh := math.max(highestHigh, high)
            // Calculate trailing stop: starts at break-even, trails based on how far price moved toward TP3
            // Trail distance = percentage of progress from TP2 to TP3
            progressToTP3 = (highestHigh - tp2Level) / (tp3Level - tp2Level)  // 0 to 1 scale
            progressToTP3 := math.min(1.0, math.max(0.0, progressToTP3))      // Clamp between 0 and 1
            // Stop trails from entry to TP2 as price moves from TP2 to TP3
            trailStop = entryPrice + (tp2Level - entryPrice) * progressToTP3

            // Update all remaining exits with trailing stop
            if currentTradeID == LONG1_ID
                strategy.exit("L1_TP1_Trail", from_entry=LONG1_ID, stop=trailStop, qty_percent=33)
                strategy.exit("L1_TP2_Trail", from_entry=LONG1_ID, limit=orb_high1 + tp2Multiplier * delta1, stop=trailStop, qty_percent=33)
                strategy.exit("L1_TP3_Trail", from_entry=LONG1_ID, limit=orb_high1 + tp3Multiplier * delta1, stop=trailStop, qty_percent=34)
            else if currentTradeID == LONG2_ID
                strategy.exit("L2_TP1_Trail", from_entry=LONG2_ID, stop=trailStop, qty_percent=33)
                strategy.exit("L2_TP2_Trail", from_entry=LONG2_ID, limit=orb_high2 + tp2Multiplier * delta2, stop=trailStop, qty_percent=33)
                strategy.exit("L2_TP3_Trail", from_entry=LONG2_ID, limit=orb_high2 + tp3Multiplier * delta2, stop=trailStop, qty_percent=34)
            else if currentTradeID == LONG3_ID
                strategy.exit("L3_TP1_Trail", from_entry=LONG3_ID, stop=trailStop, qty_percent=33)
                strategy.exit("L3_TP2_Trail", from_entry=LONG3_ID, limit=orb_high3 + tp2Multiplier * delta3, stop=trailStop, qty_percent=33)
                strategy.exit("L3_TP3_Trail", from_entry=LONG3_ID, limit=orb_high3 + tp3Multiplier * delta3, stop=trailStop, qty_percent=34)

        if isShort
            lowestLow := math.min(lowestLow, low)
            // Calculate trailing stop: starts at break-even, trails based on how far price moved toward TP3
            progressToTP3 = (tp2Level - lowestLow) / (tp2Level - tp3Level)  // 0 to 1 scale
            progressToTP3 := math.min(1.0, math.max(0.0, progressToTP3))    // Clamp between 0 and 1
            // Stop trails from entry to TP2 as price moves from TP2 to TP3
            trailStop = entryPrice - (entryPrice - tp2Level) * progressToTP3

            // Update all remaining exits with trailing stop
            if currentTradeID == SHORT1_ID
                strategy.exit("S1_TP1_Trail", from_entry=SHORT1_ID, stop=trailStop, qty_percent=33)
                strategy.exit("S1_TP2_Trail", from_entry=SHORT1_ID, limit=orb_low1 - tp2Multiplier * delta1, stop=trailStop, qty_percent=33)
                strategy.exit("S1_TP3_Trail", from_entry=SHORT1_ID, limit=orb_low1 - tp3Multiplier * delta1, stop=trailStop, qty_percent=34)
            else if currentTradeID == SHORT2_ID
                strategy.exit("S2_TP1_Trail", from_entry=SHORT2_ID, stop=trailStop, qty_percent=33)
                strategy.exit("S2_TP2_Trail", from_entry=SHORT2_ID, limit=orb_low2 - tp2Multiplier * delta2, stop=trailStop, qty_percent=33)
                strategy.exit("S2_TP3_Trail", from_entry=SHORT2_ID, limit=orb_low2 - tp3Multiplier * delta2, stop=trailStop, qty_percent=34)
            else if currentTradeID == SHORT3_ID
                strategy.exit("S3_TP1_Trail", from_entry=SHORT3_ID, stop=trailStop, qty_percent=33)
                strategy.exit("S3_TP2_Trail", from_entry=SHORT3_ID, limit=orb_low3 - tp2Multiplier * delta3, stop=trailStop, qty_percent=33)
                strategy.exit("S3_TP3_Trail", from_entry=SHORT3_ID, limit=orb_low3 - tp3Multiplier * delta3, stop=trailStop, qty_percent=34)

// Close all positions at session end
if is_end1 or is_end2 or is_end3
    strategy.close_all(comment="Session End")
