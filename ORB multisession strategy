//@version=6
// DISCLAIMER: This strategy is provided "as is" for educational purposes only. BucksTRDR is not responsible for trading decisions made using this tool. Always do your own research and consult a financial professional.
strategy('ORB Multi-Session Strategy by BucksTRDR', overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, pyramiding=0, calc_on_every_tick=false, calc_on_order_fills=false)

// === ORB Settings ===
orbTotalTime = input.int(5, title='ORB total time (minutes)')

// === SESSION 1 SETTINGS ===
sess1StopLossMult = input.float(1.0, title='S1: Stop Loss Multiplier', minval=0.1, step=0.1, group='Session 1', tooltip='Stop loss as multiple of OR range')
sess1MaxTrades = input.int(1, title='S1: Max Trades', minval=1, maxval=10, group='Session 1')
sess1MaxLosses = input.int(1, title='S1: Max Losses', minval=1, maxval=5, group='Session 1')
sess1VolMA = input.int(20, title='S1: Volume MA Length', minval=1, group='Session 1')
sess1VolMult = input.float(1.5, title='S1: Volume Multiplier', minval=0.1, step=0.1, group='Session 1')
sess1BreakoutPct = input.float(25.0, title='S1: Min Breakout %', minval=1.0, step=1.0, group='Session 1')
sess1EnableRB = input.bool(true, title='S1: Enable Rubber Band', group='Session 1')
sess1RBVolMult = input.float(1.2, title='S1: RB Volume Mult', minval=0.1, step=0.1, group='Session 1')
sess1RBRevPct = input.float(50.0, title='S1: RB Reversal %', minval=10.0, step=5.0, group='Session 1')
sess1TP1 = input.float(1.0, title='S1: TP1 Multiplier', minval=0.1, step=0.1, group='Session 1')
sess1TP2 = input.float(2.0, title='S1: TP2 Multiplier', minval=0.1, step=0.1, group='Session 1')
sess1TP3 = input.float(3.0, title='S1: TP3 Multiplier', minval=0.1, step=0.1, group='Session 1')

// === SESSION 2 SETTINGS ===
sess2StopLossMult = input.float(1.0, title='S2: Stop Loss Multiplier', minval=0.1, step=0.1, group='Session 2', tooltip='Stop loss as multiple of OR range')
sess2MaxTrades = input.int(1, title='S2: Max Trades', minval=1, maxval=10, group='Session 2')
sess2MaxLosses = input.int(1, title='S2: Max Losses', minval=1, maxval=5, group='Session 2')
sess2VolMA = input.int(20, title='S2: Volume MA Length', minval=1, group='Session 2')
sess2VolMult = input.float(1.5, title='S2: Volume Multiplier', minval=0.1, step=0.1, group='Session 2')
sess2BreakoutPct = input.float(25.0, title='S2: Min Breakout %', minval=1.0, step=1.0, group='Session 2')
sess2EnableRB = input.bool(true, title='S2: Enable Rubber Band', group='Session 2')
sess2RBVolMult = input.float(1.2, title='S2: RB Volume Mult', minval=0.1, step=0.1, group='Session 2')
sess2RBRevPct = input.float(50.0, title='S2: RB Reversal %', minval=10.0, step=5.0, group='Session 2')
sess2TP1 = input.float(1.0, title='S2: TP1 Multiplier', minval=0.1, step=0.1, group='Session 2')
sess2TP2 = input.float(2.0, title='S2: TP2 Multiplier', minval=0.1, step=0.1, group='Session 2')
sess2TP3 = input.float(3.0, title='S2: TP3 Multiplier', minval=0.1, step=0.1, group='Session 2')

// === SESSION 3 SETTINGS ===
sess3StopLossMult = input.float(1.0, title='S3: Stop Loss Multiplier', minval=0.1, step=0.1, group='Session 3', tooltip='Stop loss as multiple of OR range')
sess3MaxTrades = input.int(1, title='S3: Max Trades', minval=1, maxval=10, group='Session 3')
sess3MaxLosses = input.int(1, title='S3: Max Losses', minval=1, maxval=5, group='Session 3')
sess3VolMA = input.int(20, title='S3: Volume MA Length', minval=1, group='Session 3')
sess3VolMult = input.float(1.5, title='S3: Volume Multiplier', minval=0.1, step=0.1, group='Session 3')
sess3BreakoutPct = input.float(25.0, title='S3: Min Breakout %', minval=1.0, step=1.0, group='Session 3')
sess3EnableRB = input.bool(true, title='S3: Enable Rubber Band', group='Session 3')
sess3RBVolMult = input.float(1.2, title='S3: RB Volume Mult', minval=0.1, step=0.1, group='Session 3')
sess3RBRevPct = input.float(50.0, title='S3: RB Reversal %', minval=10.0, step=5.0, group='Session 3')
sess3TP1 = input.float(1.0, title='S3: TP1 Multiplier', minval=0.1, step=0.1, group='Session 3')
sess3TP2 = input.float(2.0, title='S3: TP2 Multiplier', minval=0.1, step=0.1, group='Session 3')
sess3TP3 = input.float(3.0, title='S3: TP3 Multiplier', minval=0.1, step=0.1, group='Session 3')

// === Timezone Selection ===
user_timezone = input.string("UTC+1", title="Your Timezone", options=["UTC", "UTC+1", "UTC+2", "UTC+3", "UTC+4", "UTC+5", "UTC+6", "UTC+7", "UTC+8", "UTC+9", "UTC+10", "UTC+11", "UTC+12", "UTC-1", "UTC-2", "UTC-3", "UTC-4", "UTC-5", "UTC-6", "UTC-7", "UTC-8", "UTC-9", "UTC-10", "UTC-11", "UTC-12"])

// === Session Configuration ===
sess1Enable = input.bool(true, title='Enable Session 1')
sess1 = input.session('0800-0805', title='Session 1 Time (Your Local Time)')
sess1Label = input.string('London OR', title='Session 1 Label')

sess2Enable = input.bool(true, title='Enable Session 2')
sess2 = input.session('1430-1535', title='Session 2 Time (Your Local Time)')
sess2Label = input.string('New York OR', title='Session 2 Label')

sess3Enable = input.bool(true, title='Enable Session 3')
sess3 = input.session('0100-0105', title='Session 3 Time (Your Local Time)')
sess3Label = input.string('Asia OR', title='Session 3 Label')

// === Session Timing Logic ===
time1 = sess1Enable ? time(timeframe.period, sess1 + ':1234567', user_timezone) : na
in_session1 = not na(time1)
is_first1 = in_session1 and not in_session1[1]
time1_end = time(timeframe.period, sess2 + ':1234567', user_timezone)
is_end1 = not na(time1_end) and na(time1_end[1])

time2 = sess2Enable ? time(timeframe.period, sess2 + ':1234567', user_timezone) : na
in_session2 = not na(time2)
is_first2 = in_session2 and not in_session2[1]
time2_end = time(timeframe.period, sess3 + ':1234567', user_timezone)
is_end2 = not na(time2_end) and na(time2_end[1])

time3 = sess3Enable ? time(timeframe.period, sess3 + ':1234567', user_timezone) : na
in_session3 = not na(time3)
is_first3 = in_session3 and not in_session3[1]
time3_end = time(timeframe.period, '1600-1601:1234567', user_timezone)
is_end3 = not na(time3_end) and na(time3_end[1])

// === ORB Storage ===
var float orb_high1 = na
var float orb_low1 = na
var float orb_high2 = na
var float orb_low2 = na
var float orb_high3 = na
var float orb_low3 = na

// === Session Display Flags ===
var bool show1 = false
var bool show2 = false
var bool show3 = false

// === Trade Counter Per Session ===
var int session1TradeCount = 0
var int session2TradeCount = 0
var int session3TradeCount = 0

// === Loss Counter Per Session ===
var int session1LossCount = 0
var int session2LossCount = 0
var int session3LossCount = 0
var int prevClosedTrades = 0  // Track number of closed trades to detect new closures

// === Position Tracking for Stop Management ===
var float entryPrice = na
var float tp2Level = na
var float tp3Level = na
var bool tp2Reached = false
var string currentTradeID = ""
var float highestHigh = na  // Track highest price for long trailing
var float lowestLow = na    // Track lowest price for short trailing

// === ORB Calculation ===
if sess1Enable
    if is_first1
        orb_high1 := high
        orb_low1 := low
        session1TradeCount := 0  // Reset trade counter
        session1LossCount := 0   // Reset loss counter
    else
        orb_high1 := orb_high1[1]
        orb_low1 := orb_low1[1]
    if in_session1
        orb_high1 := math.max(orb_high1, high)
        orb_low1 := math.min(orb_low1, low)

if sess2Enable
    if is_first2
        orb_high2 := high
        orb_low2 := low
        session2TradeCount := 0  // Reset trade counter
        session2LossCount := 0   // Reset loss counter
    else
        orb_high2 := orb_high2[1]
        orb_low2 := orb_low2[1]
    if in_session2
        orb_high2 := math.max(orb_high2, high)
        orb_low2 := math.min(orb_low2, low)

if sess3Enable
    if is_first3
        orb_high3 := high
        orb_low3 := low
        session3TradeCount := 0  // Reset trade counter
        session3LossCount := 0   // Reset loss counter
    else
        orb_high3 := orb_high3[1]
        orb_low3 := orb_low3[1]
    if in_session3
        orb_high3 := math.max(orb_high3, high)
        orb_low3 := math.min(orb_low3, low)

// === Deltas ===
delta1 = orb_high1 - orb_low1
delta2 = orb_high2 - orb_low2
delta3 = orb_high3 - orb_low3

// === Volume Calculations (Per Session) ===
volumeMA1 = ta.sma(volume, sess1VolMA)
volumeMA2 = ta.sma(volume, sess2VolMA)
volumeMA3 = ta.sma(volume, sess3VolMA)

// === Track Closed Trades for Loss Counting ===
// Check if a new trade closed and if it was a loss
if strategy.closedtrades > prevClosedTrades
    // New trade closed - check if it was a loss
    lastTradeProfit = strategy.closedtrades.profit(strategy.closedtrades - 1)
    if lastTradeProfit < 0
        // Increment loss counter for the active session
        if show1
            session1LossCount := session1LossCount + 1
        else if show2
            session2LossCount := session2LossCount + 1
        else if show3
            session3LossCount := session3LossCount + 1
    prevClosedTrades := strategy.closedtrades

// === Session Display Management ===
if sess1Enable and is_first1
    show1 := true
    show2 := false
    show3 := false
else if sess2Enable and is_first2
    show1 := false
    show2 := true
    show3 := false
else if sess3Enable and is_first3
    show1 := false
    show2 := false
    show3 := true

// Handle session end conditions
if is_end1 and show1
    show1 := false
if is_end2 and show2
    show2 := false
if is_end3 and show3
    show3 := false

// === Trade Signals ===
is5min = timeframe.isintraday and timeframe.multiplier == 5

// Session 1 signals
volumeCondition1 = volume >= sess1VolMult * volumeMA1
breakoutThreshold1 = sess1BreakoutPct / 100.0
long1Breakout = (close - orb_high1) >= (breakoutThreshold1 * delta1)
short1Breakout = (orb_low1 - close) >= (breakoutThreshold1 * delta1)
long1Basic = is5min and show1 and open < orb_high1 and close > orb_high1
short1Basic = is5min and show1 and open > orb_low1 and close < orb_low1
long1 = long1Basic and volumeCondition1 and long1Breakout and session1TradeCount < sess1MaxTrades and session1LossCount < sess1MaxLosses
short1 = short1Basic and volumeCondition1 and short1Breakout and session1TradeCount < sess1MaxTrades and session1LossCount < sess1MaxLosses

// Session 2 signals
volumeCondition2 = volume >= sess2VolMult * volumeMA2
breakoutThreshold2 = sess2BreakoutPct / 100.0
long2Breakout = (close - orb_high2) >= (breakoutThreshold2 * delta2)
short2Breakout = (orb_low2 - close) >= (breakoutThreshold2 * delta2)
long2Basic = is5min and show2 and open < orb_high2 and close > orb_high2
short2Basic = is5min and show2 and open > orb_low2 and close < orb_low2
long2 = long2Basic and volumeCondition2 and long2Breakout and session2TradeCount < sess2MaxTrades and session2LossCount < sess2MaxLosses
short2 = short2Basic and volumeCondition2 and short2Breakout and session2TradeCount < sess2MaxTrades and session2LossCount < sess2MaxLosses

// Session 3 signals
volumeCondition3 = volume >= sess3VolMult * volumeMA3
breakoutThreshold3 = sess3BreakoutPct / 100.0
long3Breakout = (close - orb_high3) >= (breakoutThreshold3 * delta3)
short3Breakout = (orb_low3 - close) >= (breakoutThreshold3 * delta3)
long3Basic = is5min and show3 and open < orb_high3 and close > orb_high3
short3Basic = is5min and show3 and open > orb_low3 and close < orb_low3
long3 = long3Basic and volumeCondition3 and long3Breakout and session3TradeCount < sess3MaxTrades and session3LossCount < sess3MaxLosses
short3 = short3Basic and volumeCondition3 and short3Breakout and session3TradeCount < sess3MaxTrades and session3LossCount < sess3MaxLosses

// === Rubber Band Reversal Signals ===
rubberBandLong = false
rubberBandShort = false

// Session-specific rubber band logic
if is5min
    prevOrbLong = long1[1] or long2[1] or long3[1]
    prevOrbShort = short1[1] or short2[1] or short3[1]

    if prevOrbLong or prevOrbShort
        prevCandleRange = high[1] - low[1]

        if prevCandleRange > 0
            // Session 1 rubber band
            if show1 and sess1EnableRB and volume >= sess1RBVolMult * volumeMA1
                reversalThreshold1 = sess1RBRevPct / 100.0
                if prevOrbLong
                    pullbackAmount = high[1] - close
                    if pullbackAmount >= (reversalThreshold1 * prevCandleRange)
                        if session1TradeCount < sess1MaxTrades and session1LossCount < sess1MaxLosses
                            rubberBandShort := true
                if prevOrbShort
                    bounceAmount = close - low[1]
                    if bounceAmount >= (reversalThreshold1 * prevCandleRange)
                        if session1TradeCount < sess1MaxTrades and session1LossCount < sess1MaxLosses
                            rubberBandLong := true

            // Session 2 rubber band
            if show2 and sess2EnableRB and volume >= sess2RBVolMult * volumeMA2
                reversalThreshold2 = sess2RBRevPct / 100.0
                if prevOrbLong
                    pullbackAmount = high[1] - close
                    if pullbackAmount >= (reversalThreshold2 * prevCandleRange)
                        if session2TradeCount < sess2MaxTrades and session2LossCount < sess2MaxLosses
                            rubberBandShort := true
                if prevOrbShort
                    bounceAmount = close - low[1]
                    if bounceAmount >= (reversalThreshold2 * prevCandleRange)
                        if session2TradeCount < sess2MaxTrades and session2LossCount < sess2MaxLosses
                            rubberBandLong := true

            // Session 3 rubber band
            if show3 and sess3EnableRB and volume >= sess3RBVolMult * volumeMA3
                reversalThreshold3 = sess3RBRevPct / 100.0
                if prevOrbLong
                    pullbackAmount = high[1] - close
                    if pullbackAmount >= (reversalThreshold3 * prevCandleRange)
                        if session3TradeCount < sess3MaxTrades and session3LossCount < sess3MaxLosses
                            rubberBandShort := true
                if prevOrbShort
                    bounceAmount = close - low[1]
                    if bounceAmount >= (reversalThreshold3 * prevCandleRange)
                        if session3TradeCount < sess3MaxTrades and session3LossCount < sess3MaxLosses
                            rubberBandLong := true

// === STRATEGY ENTRIES ===

// Entry IDs for tracking
var string LONG1_ID = "Long1"
var string SHORT1_ID = "Short1"
var string LONG2_ID = "Long2"
var string SHORT2_ID = "Short2"
var string LONG3_ID = "Long3"
var string SHORT3_ID = "Short3"
var string RB_LONG_ID = "RB_Long"
var string RB_SHORT_ID = "RB_Short"

// Session 1 entries
if long1
    stopLoss = orb_low1 - (sess1StopLossMult * delta1)
    strategy.entry(LONG1_ID, strategy.long, comment="L1")
    strategy.exit("L1_TP1", from_entry=LONG1_ID, limit=orb_high1 + sess1TP1 * delta1, stop=stopLoss, qty_percent=33)
    strategy.exit("L1_TP2", from_entry=LONG1_ID, limit=orb_high1 + sess1TP2 * delta1, stop=stopLoss, qty_percent=33)
    strategy.exit("L1_TP3", from_entry=LONG1_ID, limit=orb_high1 + sess1TP3 * delta1, stop=stopLoss, qty_percent=34)
    session1TradeCount := session1TradeCount + 1
    // Track position details
    entryPrice := close
    tp2Level := orb_high1 + sess1TP2 * delta1
    tp3Level := orb_high1 + sess1TP3 * delta1
    tp2Reached := false
    currentTradeID := LONG1_ID
    highestHigh := high
    lowestLow := na

if short1
    stopLoss = orb_high1 + (sess1StopLossMult * delta1)
    strategy.entry(SHORT1_ID, strategy.short, comment="S1")
    strategy.exit("S1_TP1", from_entry=SHORT1_ID, limit=orb_low1 - sess1TP1 * delta1, stop=stopLoss, qty_percent=33)
    strategy.exit("S1_TP2", from_entry=SHORT1_ID, limit=orb_low1 - sess1TP2 * delta1, stop=stopLoss, qty_percent=33)
    strategy.exit("S1_TP3", from_entry=SHORT1_ID, limit=orb_low1 - sess1TP3 * delta1, stop=stopLoss, qty_percent=34)
    session1TradeCount := session1TradeCount + 1
    // Track position details
    entryPrice := close
    tp2Level := orb_low1 - sess1TP2 * delta1
    tp3Level := orb_low1 - sess1TP3 * delta1
    tp2Reached := false
    currentTradeID := SHORT1_ID
    highestHigh := na
    lowestLow := low

// Session 2 entries
if long2
    stopLoss = orb_low2 - (sess2StopLossMult * delta2)
    strategy.entry(LONG2_ID, strategy.long, comment="L2")
    strategy.exit("L2_TP1", from_entry=LONG2_ID, limit=orb_high2 + sess2TP1 * delta2, stop=stopLoss, qty_percent=33)
    strategy.exit("L2_TP2", from_entry=LONG2_ID, limit=orb_high2 + sess2TP2 * delta2, stop=stopLoss, qty_percent=33)
    strategy.exit("L2_TP3", from_entry=LONG2_ID, limit=orb_high2 + sess2TP3 * delta2, stop=stopLoss, qty_percent=34)
    session2TradeCount := session2TradeCount + 1
    // Track position details
    entryPrice := close
    tp2Level := orb_high2 + sess2TP2 * delta2
    tp3Level := orb_high2 + sess2TP3 * delta2
    tp2Reached := false
    currentTradeID := LONG2_ID
    highestHigh := high
    lowestLow := na

if short2
    stopLoss = orb_high2 + (sess2StopLossMult * delta2)
    strategy.entry(SHORT2_ID, strategy.short, comment="S2")
    strategy.exit("S2_TP1", from_entry=SHORT2_ID, limit=orb_low2 - sess2TP1 * delta2, stop=stopLoss, qty_percent=33)
    strategy.exit("S2_TP2", from_entry=SHORT2_ID, limit=orb_low2 - sess2TP2 * delta2, stop=stopLoss, qty_percent=33)
    strategy.exit("S2_TP3", from_entry=SHORT2_ID, limit=orb_low2 - sess2TP3 * delta2, stop=stopLoss, qty_percent=34)
    session2TradeCount := session2TradeCount + 1
    // Track position details
    entryPrice := close
    tp2Level := orb_low2 - sess2TP2 * delta2
    tp3Level := orb_low2 - sess2TP3 * delta2
    tp2Reached := false
    currentTradeID := SHORT2_ID
    highestHigh := na
    lowestLow := low

// Session 3 entries
if long3
    stopLoss = orb_low3 - (sess3StopLossMult * delta3)
    strategy.entry(LONG3_ID, strategy.long, comment="L3")
    strategy.exit("L3_TP1", from_entry=LONG3_ID, limit=orb_high3 + sess3TP1 * delta3, stop=stopLoss, qty_percent=33)
    strategy.exit("L3_TP2", from_entry=LONG3_ID, limit=orb_high3 + sess3TP2 * delta3, stop=stopLoss, qty_percent=33)
    strategy.exit("L3_TP3", from_entry=LONG3_ID, limit=orb_high3 + sess3TP3 * delta3, stop=stopLoss, qty_percent=34)
    session3TradeCount := session3TradeCount + 1
    // Track position details
    entryPrice := close
    tp2Level := orb_high3 + sess3TP2 * delta3
    tp3Level := orb_high3 + sess3TP3 * delta3
    tp2Reached := false
    currentTradeID := LONG3_ID
    highestHigh := high
    lowestLow := na

if short3
    stopLoss = orb_high3 + (sess3StopLossMult * delta3)
    strategy.entry(SHORT3_ID, strategy.short, comment="S3")
    strategy.exit("S3_TP1", from_entry=SHORT3_ID, limit=orb_low3 - sess3TP1 * delta3, stop=stopLoss, qty_percent=33)
    strategy.exit("S3_TP2", from_entry=SHORT3_ID, limit=orb_low3 - sess3TP2 * delta3, stop=stopLoss, qty_percent=33)
    strategy.exit("S3_TP3", from_entry=SHORT3_ID, limit=orb_low3 - sess3TP3 * delta3, stop=stopLoss, qty_percent=34)
    session3TradeCount := session3TradeCount + 1
    // Track position details
    entryPrice := close
    tp2Level := orb_low3 - sess3TP2 * delta3
    tp3Level := orb_low3 - sess3TP3 * delta3
    tp2Reached := false
    currentTradeID := SHORT3_ID
    highestHigh := na
    lowestLow := low

// Rubber Band entries (Note: RB trades use simpler TP structure, no trailing)
if rubberBandLong
    if show1
        stopLoss = low - (sess1StopLossMult * delta1)
        session1TradeCount := session1TradeCount + 1
    else if show2
        stopLoss = low - (sess2StopLossMult * delta2)
        session2TradeCount := session2TradeCount + 1
    else if show3
        stopLoss = low - (sess3StopLossMult * delta3)
        session3TradeCount := session3TradeCount + 1

    currentDelta = show1 ? delta1 : show2 ? delta2 : delta3
    strategy.entry(RB_LONG_ID, strategy.long, comment="RB_L")
    strategy.exit("RB_L_Exit", from_entry=RB_LONG_ID, limit=high + currentDelta, stop=stopLoss)
    // Reset tracking since RB doesn't use trailing
    entryPrice := na
    tp2Level := na
    tp2Reached := false
    currentTradeID := ""

if rubberBandShort
    if show1
        stopLoss = high + (sess1StopLossMult * delta1)
        session1TradeCount := session1TradeCount + 1
    else if show2
        stopLoss = high + (sess2StopLossMult * delta2)
        session2TradeCount := session2TradeCount + 1
    else if show3
        stopLoss = high + (sess3StopLossMult * delta3)
        session3TradeCount := session3TradeCount + 1

    currentDelta = show1 ? delta1 : show2 ? delta2 : delta3
    strategy.entry(RB_SHORT_ID, strategy.short, comment="RB_S")
    strategy.exit("RB_S_Exit", from_entry=RB_SHORT_ID, limit=low - currentDelta, stop=stopLoss)
    // Reset tracking since RB doesn't use trailing
    entryPrice := na
    tp2Level := na
    tp2Reached := false
    currentTradeID := ""

// === DYNAMIC STOP MANAGEMENT ===
// Move to break-even when TP2 is hit, then trail toward TP3
if strategy.position_size != 0 and not na(entryPrice) and not na(tp2Level)
    isLong = strategy.position_size > 0
    isShort = strategy.position_size < 0

    // Check if TP2 has been reached
    if not tp2Reached
        if (isLong and high >= tp2Level) or (isShort and low <= tp2Level)
            tp2Reached := true

    // Update stops dynamically after TP2 is reached
    if tp2Reached
        // Track highest/lowest since TP2 reached
        if isLong
            highestHigh := math.max(highestHigh, high)
            // Calculate trailing stop: starts at break-even, trails based on how far price moved toward TP3
            // Trail distance = percentage of progress from TP2 to TP3
            progressToTP3 = (highestHigh - tp2Level) / (tp3Level - tp2Level)  // 0 to 1 scale
            progressToTP3 := math.min(1.0, math.max(0.0, progressToTP3))      // Clamp between 0 and 1
            // Stop trails from entry to TP2 as price moves from TP2 to TP3
            trailStop = entryPrice + (tp2Level - entryPrice) * progressToTP3

            // Update all remaining exits with trailing stop
            if currentTradeID == LONG1_ID
                strategy.exit("L1_TP1_Trail", from_entry=LONG1_ID, stop=trailStop, qty_percent=33)
                strategy.exit("L1_TP2_Trail", from_entry=LONG1_ID, limit=orb_high1 + sess1TP2 * delta1, stop=trailStop, qty_percent=33)
                strategy.exit("L1_TP3_Trail", from_entry=LONG1_ID, limit=orb_high1 + sess1TP3 * delta1, stop=trailStop, qty_percent=34)
            else if currentTradeID == LONG2_ID
                strategy.exit("L2_TP1_Trail", from_entry=LONG2_ID, stop=trailStop, qty_percent=33)
                strategy.exit("L2_TP2_Trail", from_entry=LONG2_ID, limit=orb_high2 + sess2TP2 * delta2, stop=trailStop, qty_percent=33)
                strategy.exit("L2_TP3_Trail", from_entry=LONG2_ID, limit=orb_high2 + sess2TP3 * delta2, stop=trailStop, qty_percent=34)
            else if currentTradeID == LONG3_ID
                strategy.exit("L3_TP1_Trail", from_entry=LONG3_ID, stop=trailStop, qty_percent=33)
                strategy.exit("L3_TP2_Trail", from_entry=LONG3_ID, limit=orb_high3 + sess3TP2 * delta3, stop=trailStop, qty_percent=33)
                strategy.exit("L3_TP3_Trail", from_entry=LONG3_ID, limit=orb_high3 + sess3TP3 * delta3, stop=trailStop, qty_percent=34)

        if isShort
            lowestLow := math.min(lowestLow, low)
            // Calculate trailing stop: starts at break-even, trails based on how far price moved toward TP3
            progressToTP3 = (tp2Level - lowestLow) / (tp2Level - tp3Level)  // 0 to 1 scale
            progressToTP3 := math.min(1.0, math.max(0.0, progressToTP3))    // Clamp between 0 and 1
            // Stop trails from entry to TP2 as price moves from TP2 to TP3
            trailStop = entryPrice - (entryPrice - tp2Level) * progressToTP3

            // Update all remaining exits with trailing stop
            if currentTradeID == SHORT1_ID
                strategy.exit("S1_TP1_Trail", from_entry=SHORT1_ID, stop=trailStop, qty_percent=33)
                strategy.exit("S1_TP2_Trail", from_entry=SHORT1_ID, limit=orb_low1 - sess1TP2 * delta1, stop=trailStop, qty_percent=33)
                strategy.exit("S1_TP3_Trail", from_entry=SHORT1_ID, limit=orb_low1 - sess1TP3 * delta1, stop=trailStop, qty_percent=34)
            else if currentTradeID == SHORT2_ID
                strategy.exit("S2_TP1_Trail", from_entry=SHORT2_ID, stop=trailStop, qty_percent=33)
                strategy.exit("S2_TP2_Trail", from_entry=SHORT2_ID, limit=orb_low2 - sess2TP2 * delta2, stop=trailStop, qty_percent=33)
                strategy.exit("S2_TP3_Trail", from_entry=SHORT2_ID, limit=orb_low2 - sess2TP3 * delta2, stop=trailStop, qty_percent=34)
            else if currentTradeID == SHORT3_ID
                strategy.exit("S3_TP1_Trail", from_entry=SHORT3_ID, stop=trailStop, qty_percent=33)
                strategy.exit("S3_TP2_Trail", from_entry=SHORT3_ID, limit=orb_low3 - sess3TP2 * delta3, stop=trailStop, qty_percent=33)
                strategy.exit("S3_TP3_Trail", from_entry=SHORT3_ID, limit=orb_low3 - sess3TP3 * delta3, stop=trailStop, qty_percent=34)

// Close all positions at session end
if is_end1 or is_end2 or is_end3
    strategy.close_all(comment="Session End")
